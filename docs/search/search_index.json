{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction These materials aim to help undergraduate students explore and understand changes in the global environment using Google Earth Engine. They introduce core concepts of geographic information systems and remote sensing, methods for implementing these concepts with Earth Engine\u2019s javascript code editor, and a series of real-world problems and applications. This is a work in progress. I will be using it in Fall 2022 to teach a course in Environmental Studies and Geography at Middlebury College and it will be updated continuously. I\u2019ve organized the primer into chapters that each contain about a week\u2019s worth of content. Each chapter contains three sections: Introduces key words, concepts, and principles of spatial analysis, spatial problem-solving, geographic information systems, and remote sensing. Introduces code snippets to implement concepts with Google Earth Engine\u2019s code editor. Sketches geographic and environmental problems for students to solve by bringing together concepts and code. I am also developing problem sets to assess near and far transfer of understanding. In my course, these function as exams and for that reason I keep them in a private repository. If you are an instructor who would like access to these materials, please contact me. Jeff Howarth Associate Professor of Geography Middlebury College, Middlebury, Vermont, USA jhowarth@middlebury.edu","title":"Introduction"},{"location":"00/code/account/","text":"You will need to sign up for a Google Earth Engine account. This is free for students. We will walk through the sign-up process in our first meeting. You sign up through the Google Earth Engine web site .","title":"Account"},{"location":"00/code/code_editor/","text":"Earth Engine Code Editor We will use the web-based Code Editor for Earth Engine. You might as well bookmark this site in your browser. It provides an interface for writing and running code, while also providing tools for managing files and assets, composing and inspecting maps, finding documentation, and printing results and widgets. The diagram shown below is from Google\u2019s Earth Engine documentation . As you can see, the Code Editor consists of a lot of panels and buttons. As you use the code editor, you will quickly become familiar with navigating the interface. In our first lab meeting, we will go over the following common tasks. Common Task Panel or button Manage files Scripts Assets Find help for tools Docs Write and run code Text Editor Save Inspect results Console Inspect locations Inspector Inspect tasks Tasks Navigate map Pan Zoom Change basemap Map Satellite Draw geometry Point Line Shape Rectangle","title":"Code Editor"},{"location":"00/code/javaScript101/","text":"JavaScript 101 The Code Editor lets you work with Earth Engine by writing code in JavaScript. Like any language, JavaScript has a vocabulary and grammar that you will learn through practice. This page introduces some key terms, syntax, and contexts for writing code with JavaScript. Like most of the pages tagged with in this primer, this page contains code snippets that you can copy and paste into the code editor to see their effects. To do this, open the code editor , copy and past the code snippets into it, and click RUN to execute the snippet. You can also save you script as a file by clicking the SAVE button. The file name should not have spaces and should end with .js to mark that it is a JavaScript file (e.g. javascript101.js ). Scripts A script is a sequence of statements that can be executed (when you \u2018run\u2019 the script). Lines A line is the basic organizing unit of a script. Think of a line like a ruling on a sheet of paper, while a statement is like the sentence that you write on the ruling. Each line has a number, shown on the left side of the text editor panel. These line indexes are helpful for troubleshooting code because if you make an error the code editor will usually tell you the line number that tripped it up. Comments A comment tells the computer: please ignore this . You often use comments to document your code and write little notes to yourself and to people who may read and want to reuse your code. They are like putting notes in the margins of a book without affecting the content of the book or like the director\u2019s commentary of a movie that can be muted when you watch. A line comment tells the computer not to execute anything that follows two forward slashes on a line. A multi-line comment tells the computer not to execute anything from a defined beginning and ending which may span multiple lines. // LINE COMMENTS start with two forward slashes. Like this line. The computer won't execute anything on this line that follows the slashes. /* MULTI LINE COMMENTS start with a forward slash and a star and end with a star and a forward slash. The computer won't execute anything between the stars, even if your comment spans many many lines . */ Script header It is good practice to begin every script with a header that states a title, your name, the date, and a brief description of the script\u2019s purpose. To do this, you can use either a line comment or multi-line comment. Here is an example of a header with line comments. Note how each line begins with two forward slashes. // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // TITLE: Javascript 101 // NAME: Your name here please // DATE: Today's date // PURPOSE: Getting started with JavaScript // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Here is an example of a header with a multi-line comment. /* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ TITLE: Javascript 101 NAME: Your name here please DATE: Today's date PURPOSE: Getting started with JavaScript ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */ Either method is fine. The most important thing is to remember to start each script with a header. Statements, objects, and variables When you write a script, you write statements to create and manipulate different kinds of data objects . An object class is an abstract template, while an instance is a manifestation of it. For example, the concept of \u2018a book\u2019 is like an object class, while \u2018the book sitting next to your bed\u2019 is an instance of this class. Sometimes you hear the words \u201ctype\u201d and \u201ctoken\u201d to describe the same distinction. A common statement involves first creating a container to store something and then putting an instance of a class into the container. In JavaScript, the container is called a variable . A variable can store different kinds of objects and you can name the variable (almost) anything that you want. // This statement creates the variable age_daughter to store an instance of a NUMBER object. var age_daughter = 4 ; // This statement creates the variable age_son to store an instance of a STRING object. A string starts and ends with a single quote. var age_son = 'six years old' ; // A string object can also start and end with double quotes, // (but don't mix and match them). var name_daughter = \"isabel\" ; // This variable stores a set of strings as a LIST object that is defined by square brackets. var kid_names = [ 'Aldo' , 'Isabel' ]; // This list stores a set of numbers. var kid_ages = [ 6 , 4 ]; // Curly brackets (or braces) can be used to define DICTIONARIES, or a set of KEY:VALUE pairs. var kidStats = { 'name' : 'Aldo' , 'age' : 6 , 'birthplace' : 'Middlebury, VT' }; Statement syntax If you examine these simple statements, you might recognize some basic rules of syntax. 1. How do you define a variable? In JavaScript, the statement starts with the keyword var followed by the equal sign. That clause says \u2018create a variable named\u2026\u2019. 2. What do you notice about the variable names? They follow a simple rule: The name of a variable cannot contain spaces. To honor this rule, you can follow two naming conventions for variables. // An example of the snake_case. var this_will_work = 'snake_case' ; // An example of the camelCase. var thisWillAlsoWork = 'camelCase' ; 3. What defines the object class of the instance? This is subtle, but important. The object class is coded by the format of the text in the statement. OBJECT CLASS FORMAT EXAMPLE NUMBER plain old number 4 STRING \u2018 \u2018 \u201d \u201c \u2018isabel\u2019 \u201ckid\u2019s\u201c LIST [ ] [\u2018aldo\u2019, \u2018isabel\u2019] DICTIONARY {:} {\u2018name\u2019: \u2018aldo\u2019} 4. How does each statement end? Do you see that little thing at the end of each statement winking at you? This is a mark of good coding practice: Statements should end in a semi-colon . // Statements should end in a SEMI-COLON, or the editor complains. var dangling = 'I feel incomplete...' var complete = 'This feels better, thanks.' ; In the above example, the editor will flag the line with a little italic i when you forget the semi-colon, but you may not notice this because the code will often still run. As you learn to write more complicated statements, however, forgetting to include a semi-colon can torpedo your code from executing. So it is good practice to think of the semi-colon as the period of a sentence and always end with it. Code documentation It is good practice to write comments to document every statement in your code. This will help you read your code if you put a script down for a period of time and return to it later. It will also help other people read and borrow from your code or help you troubleshoot errors. In this course, I will ask you to follow three principles of good coding practice with respect to documenting your scripts. 1. Write a comment for each statement that briefly describes its purpose. 2. Always document code with complete sentences that end with periods. 3. Write concise 1-2 sentence statements, not long-winded paragraphs. Print to console panel As you write code, it is good practice to check your work as you go. A common way of doing this is to print variables and then look at the result in the Console panel of the Code Editor. // Use print function and pass a string to it by enclosing in parentheses. print ( 'This string will print in the Console panel.' ); // You can also pass a variable to the print function. print ( kid_names ); // Use commas to pass more than one item to the print function. print ( \"my kids\" , kid_names ); Functions The print command is an example of a function , or something more like a verb than a noun. A function can take arguments and deliver results. As illustrated by the print function, you pass arguments to a function by enclosing them in parentheses. Object methods Every object class will have a set of functions that you can call to manipulate instances of that object class. These are often called methods . Here is an example for a list object. // Use a period and parentheses to call a METHOD of an object (a function that works with an object). var kids_reversed = kid_names . reverse (); print ( 'Kids in reverse order' , kids_reversed ); Earth Engine objects All the examples above deal with native JavaScript objects and methods. Earth Engine provides a large set of additional objects and methods for working with geographic information. In the chapters that follow, you will learn how to use JavaScript to access these tools. The syntax and grammar for using these tools are largely the same as what we have discussed above. If this all feels new and slightly overwhelming, please do not stress out. It will become familiar through practice. Adapted from Earth Engine 101 by Dave Thau .","title":"Javascript 101"},{"location":"01/apply/discussion/","text":"Discussion Drawing lines on Mercator The True Size of SIN-EWR on sphere SIN-EWR last weekend Geographic friction EWR-SIN last weekend Geopolitical friction","title":"Discussion"},{"location":"01/apply/longest_haul/","text":"The Shortest Route for the Longest Haul Currently, the longest non-stop commercial flight connects Singapore (SIN) to Newark (EWR). Does the flight path follow the great circle route between the two airports? In theory, this route represents the shortest geographic distance between these two locations. To begin to answer this question, please create a map that shows the great circle route between the two airports. Please copy and paste the starter script (below) into the code editor and then save it to your repo. Please write one or more lines of code to \u2018answer\u2019 each prompt. We will discuss both your solution (script) and our original question (does the flight follow the great circle route?) in our next class meeting. At that time, I will also show you how to submit your scripts and document your coursework this semester. Starter script // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // Problem: The longest haul // Date: Today's date // Student: Your name here please // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // Construct point geometry objects for SIN and EWR. // Construct line geometry object between the two airports. // Calculate the length of the route. // Make a feature called 'longest_haul' with the line geometry and the distance of the flight as an attribute. // Inspect the result by printing to Console. // Center the map as follows: // latitude: -0.9678795804756186 // longitude: -82.83931467161779 // zoom level: 3 // Change the base map to hybrid. // Add the line feature to the map, display it with red, and label the layer 'Longest haul route'. Airport support To help you find the airports, here is a screen shot that shows the location of SIN: And here is another that shows the location of EWR.","title":"Shortest route for the longest haul"},{"location":"01/code/addLayer/","text":"Add layer to map If you have one or more point, line, or polygon objects stored as a variable, you can display the variable on the Map UI as a layer . The layer metaphor goes back to the days when people would place a mylar sheet on top of a reference map and then draw shapes on the mylar. Thus the reference map was the base layer and each mylar sheet put on top of it was a thematic layer . Even though we don\u2019t use mylar anymore, the map layer metaphor is helpful as a conceptual device. In the example below, I assume you have a point object named \u2018point\u2019. Map . addLayer ( point , // Geometry object to show on the map. { color : 'blue' }, // Color to display the objects. 'My first point' // A label for the layer that will appear in the label panel. ); Please note: If you don\u2019t seen the point on your map, it may be because it is not in your current map extent. So you will need to zoom out and pan around to find it. Check your understanding How would you change the display so that the point appears red?","title":"Add layer to map"},{"location":"01/code/calculateLength/","text":"Calculate length Geometry objects have implicit spatial properties, like length, area, center, etc. Earth Engine provides methods to calculate these for each geometry class. For example, the method .length() calculates the length of a line (or \u2018LineString\u2019) object. To call the method, you append .length() to the variable that stores the line object. The snippet below assumes that you have a line object named \u2018line\u2019. // Calculate the length of a line object. var line_length = line . length () ; // Inspect result. print ( 'route distance' , line_length ); Check your understanding What statement would you write to find the center of the line? Hint: use the Docs tab to look for a method associated with ee.Geometry.LineString that sounds like it would calculate the center of the line.","title":"Calculate line length"},{"location":"01/code/centerObject/","text":"Center map on an object You can also define your map extent so that the map centers on a geometry object, like a sample point or city center. In the example below, I assume you have a point object named \u2018point\u2019. // Center on a point. Map . centerObject ( point , 4 ); Check your understanding If you have the choice, should you center the map before you add a layer, or add a layer before you center the map, or do you think that the sequence really does not matter?","title":"Center map on object"},{"location":"01/code/constructFeature/","text":"Construct a feature A geometry object represents where , but not what is where. In other words, geometry objects represent geographic locations, but they do not describe conditions or properties of these locations. For example, you can store the location of a town with a geometry object, but not the town\u2019s name, population, area, etc. A feature object stores both the geometry and qualitative and/or quantitative properties of a location. Often, you will hear people who are accustomed to geographic information systems use the word attribute rather than property. For our purposes, they are synonymous. Usually, the attributes of features will be defined as part of a data product. But you can also define and alter attributes as necessary with code. Earth Engine provides a method to make features by calling ee.Feature(). As arguments (between the parentheses), it takes a geometry object and the attributes. The attributes must be defined as a dictionary with a key and a value. You might think of this like a data table: the key is the column title and the value is the row. The example below again assumes that you have a point object named \u2018point\u2019. // Set a property of point. var point_feature = ee . Feature ( point , { name : 'my first point' }); // Print the two different objects to compare. print ( 'Point as geometry' , point , 'Point as feature' , point_feature ); Check your understanding Try to change the name of the feature to 'Gulf of Guinea'. What does the statement now say?","title":"Construct a feature"},{"location":"01/code/constructLineGeometry/","text":"Construct line geometry A line consists of two or more points. When you stretch a string tightly between two points on a globe, you show the great circle route . This shows the shortest distance across the globe\u2019s surface between the two points. Google Earth Engine uses a spheroid model to represent line objects. The resulting lines represent great circle routes, just like if you were working with a string and a globe. Earth Engine provides a method to construct line objects from two or more points. You call the method with the phrase ee.Geometry.LineString(). It takes a list of points as an argument. // Construct two points. var point = ee . Geometry . Point ([ 0 , 0 ]); var point2 = ee . Geometry . Point ([ - 90 , 60 ]); // Construct line from two points. var line = ee . Geometry . LineString ([ point , point2 ]); // Inspect results. print ( 'Great circle arc' , line ); // Display result as a layer on the map. Map . addLayer ( line , { color : 'red' }, 'Great circle line' ); Check your understanding If this line represents the shortest distance between two points, why does the line bend rather than go straight?","title":"Construct line geometry"},{"location":"01/code/constructPointGeometry/","text":"Construct point geometry While you can create geometry objects with the drawing buttons in the upper-left of the Map user interface, you can also create them with code. Earth Engine provides a method to make a point from coordinates (x,y). You call the method with the phrase ee.Geometry.Point(). Then you tell it the coordinates in the parentheses. To work, the coordinates need to be in the form of a list. // Construct new point geometry object. var point = ee . Geometry . Point ([ 0 , 0 ]); // Inspect the result. print ( 'Point object' , point ); Check your understanding Which number represents the Prime Meridian Which number represents the Equator?","title":"Construct point geometry"},{"location":"01/code/convert_units/","text":"Convert units By default, Earth Engine often computes spatial measurements in meters. So length returns meters and area returns square meters. (It is good practice to use the docs tab in the code editor to double-check the units returned by your method.) You can convert these units into meters through simple math operations of number objects. The example below converts meters to kilometers. The snippet below assumes that you have a line object named \u2018line\u2019. // Calculate the length of a line object. var line_length_km = line . length () . divide ( 1000 ) ; // Inspect result. print ( 'route distance kilometers' , line_length_km ); Check your understanding How would you convert meters to miles?","title":"Convert units"},{"location":"01/code/getMapCenter/","text":"Get map center When you first open the Code Editor , the Map UI will be centered on a point in Buffalo Valley, OK. You can retrieve the coordinates of a map\u2019s center with this: // Get map center. var center = Map . getCenter (); print ( 'Center point' , center ); Please copy and paste the above code snippet into the Code Editor, then run it, and try to answer the questions below. Check your understanding: Please look at the Console Panel. Which number represents latitude and which represents longitude? What does it mean if a number is negative? Please write down the coordinates that you printed to the Console. Now click the pan button (the little glove in the upper left of the Map UI), then click the map and, while holding your click, drag towards your left. Now run the code again and try to answer the questions below. Check your understanding: Again, please look at the Console Panel. Which number changed the most when you panned? How did it change? Do you think you are moving the map when you pan, or are you moving the window through which you are looking at the map?","title":"Get map center"},{"location":"01/code/getZoom/","text":"Get zoom level By default, the map will always initialize so that you see all of the lower 48 states (plus Puerto Rico) in the map window. After panning the map in the last step, you have changed the region of the world displayed on the map. But you have not changed the amount of detail that the map displays. In the Map UI, zoom level defines the amount of detail displayed on the map. You can retrieve the zoom level used to display a map with this: // Get zoom level of map. var zoom = Map . getZoom (); print ( 'Zoom level' , zoom ); Check your understanding: Use the + and - buttons at the top left of the Map UI and re-run the code snippet to answer these two questions. What zoom level is the most 'zoomed out'? What zoom level is the most 'zoomed in'?","title":"Get zoom"},{"location":"01/code/setBasemap/","text":"Set base map By default, the Code Editor map will display with the Google road map. You can change the default basemap type like this: Map . setOptions ( 'HYBRID' ); You may choose from four base map types: \u2018ROADMAP\u2019 \u2018SATELLITE\u2019 \u2018HYBRID\u2019 \u2018TERRAIN\u2019 Check your understanding: What object type does this method take as a parameter?","title":"Set base map"},{"location":"01/code/setCenterZoom/","text":"Set map center and zoom level Together, map center and zoom level define a map\u2019s extent. You can customize the map extent by changing the map center and zoom level like this: // Set map center and zoom. Map . setCenter ( - 73.1812983597342 , 44.013157468373876 , 19 ); Check your understanding: At this zoom level, how many decimal places do you really need to center the map at this location? Hint: remove a decimal from the two coordinates and re-run the script. Repeat until you see first see BiHall move (just a tad).","title":"Set map center and zoom"},{"location":"01/concepts/geographic_framework/","text":"Geographic Framework Key terms equator prime meridian latitude longitude great circle zoom level representative fraction (RF) scale","title":"Geographic framework"},{"location":"01/concepts/modeling/","text":"Cartographic Modeling Key terms task ( goal ) task hierarchy workflow ( procedure , program )","title":"Cartographic modeling"},{"location":"01/concepts/transformations/","text":"Transformations Key terms Terms in italics are synonyms. input operation ( method ) output parameters ( arguments ) data types ( object classes )","title":"Transformations"},{"location":"01/concepts/vectorModel/","text":"Vector model Key terms Geometry (points, lines, polygons) Attributes (spatial, thematic) Singlepart versus multipart Properties","title":"Vector model"},{"location":"02/apply/corridor_easement_list/","text":"River corridor easement outreach The State of Vermont\u2019s Climate Action Plan anticipates that the next century will bring broad shifts in local patterns of precipitation and temperature. Annual temperatures are projected to increase over 2\u00b0F by 2050 and between 4 to 9\u00b0F by 2100. The number of days with extreme heat (defined by a high temperature of at least 90\u00b0F) are projected to double in frequency to nine days a year by 2050 and then increase to between 15 and 45 days a year by the century\u2019s end. Annual precipitation is projected to increase one to two inches by 2050 and between four and nine inches by 2100. Much of this increased precipitation will be delivered in higher intensity storms, as extreme precipitation events (those with more than two inches of rain in a 24-hour period) are expected to increase. These changes will directly impact the ecological function and habitat of lands for native plant and animal species. As a result, the goal of protecting 30 percent of terrestrial lands and waters by 2030 has been widely recognized as a pillar of climate change planning. The United Nations Convention on Biodiversity adopted 30 by \u201830 goal as one of ten \u2018milestones\u2019 in a global framework for managing nature through 2030. President Biden\u2019s 2021 \u201cExecutive Order on Tackling the Climate Crisis at Home and Abroad\u201d also adopted the 30 by \u201830 goal. In Vermont, the River Corridor Easement Program is one instrument available to compensate private land owners for extending protections on their lands. Your goal this week is to write a script in Earth Engine that identifies property owners with at least 50 acres of land within a designated river corridor for any watershed in Vermont. This tool could be used by municipal Conservation Commissions and private Land Trusts to contact land owners and initiate conversations that help us get closer to reaching 30 by \u201830 and subsequent 50 by \u201850 conservation goals. The app below illustrates that basic tool that you will make. Here is a link to the app that will open in a separate window. The CODE section below introduces the methods that you will use to make this app. Each snippet introduces a method with a toy case. Your task in our lab meeting will be to arrange these methods into a workflow that produces a map like the one shown above.","title":"River corridor easement outreach"},{"location":"02/apply/starter_script/","text":"// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // TITLE: week_02_practice_problem.js // NAME: Your name here please // DATE: Today's date // PURPOSE: Identify opportunities for river corridor easements. // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // Use the drawing tool to drop a point on the Battell Bridge. // -------------------------------------------------------------------------------- // 1. Load watersheds and filter for Vermont and study region. // -------------------------------------------------------------------------------- // Load watersheds from Earth Engine data catalog. Search for 'HUC12'. // Print first feature in collection in order to examine the table structure. // Filter the feature collection by attribute to keep only watersheds in the state of Vermont. // Create a study region by selecting the Vermont watershed that intersects the point of interest. // -------------------------------------------------------------------------------- // 2. Set up map and add watershed layers. // -------------------------------------------------------------------------------- // Center map study region and set zoom 11. // Set base map to satellite image with labels. // Add layer of Vermont watersheds to map. Use color 'LightCyan' and 0.5 opacity. // Add layer of study region to map. Use color 'PaleTurquoise' // ================================================================================ // Dataset addresses that are not in Earth Engine Data Catalog. // ================================================================================ var datasets = { parcels : 'projects/conservation-atlas/assets/cadastre/VTPARCELS_poly_standardized_parcels_SP_v1' , river_corridors : 'projects/conservation-atlas/assets/hydrology/WaterHydro_RiverCorridors_poly' , } ; // -------------------------------------------------------------------------------- // 3. Show river corridor that overlaps the study region. // -------------------------------------------------------------------------------- // Construct a feature collection from the river corridors address. // Filter the collection for features that intersect the study region. // Union the features within the collection. // Add the result from the last step to the map. Use color 'LightSkyBlue'. // -------------------------------------------------------------------------------- // 4. Show property parcels that overlap the river corridor in the study region. // -------------------------------------------------------------------------------- // Construct a feature collection from the parcels address. // Filter the feature collection for features that intersect the river corridors in the study region. // Filter the feature collection by attribute to keep features that are parcels (not roads, water, etc). /* Please note: to do the last step (filter by attribute), you will need to: 1. Find the property keys for the features and figure out which one describes the parcel property type. 2. Then you need to find the list of values for this key (so that you can see how the data distinguishes owned parcels from roads, water, etc). */ // Add result from last step as layer to map. Use color 'Gainsboro'. // -------------------------------------------------------------------------------- // 5. Show intersections of parcels and river corridors in the study region. // -------------------------------------------------------------------------------- // Create function to intersect each parcel (from step 3) by river corridor (from step 3). // Please ask for help if you get stuck here. // Apply the function to every parcel in the featue collection. // Add the result to the map. Use color 'LightSkyBlue'. // -------------------------------------------------------------------------------- // 6. Show features that meet an area criterion. // -------------------------------------------------------------------------------- // Write a function to compute area of each feature and append result to each feature as the property 'ACRES'. // Filter the result of above for all features that are greater than 50 acres. // Add the result as a layer to map. Use color 'Orchid'. // -------------------------------------------------------------------------------- // 7. Display results as a table. // -------------------------------------------------------------------------------- // We will discuss this last step in class tomorrow.","title":"Starter script"},{"location":"02/code/aggregate_array/","text":"Inspect unique values of one property // ---------------------------------------------------------------------------- // Inspect all the unique values for one property of features in the collection. // ---------------------------------------------------------------------------- // 1. Get list. var value_list = point_collection . aggregate_array ( 'name' ) . distinct () . sort () ; // 2. Print list. print ( 'list of values' , value_list );","title":"Inspect unique values of one property"},{"location":"02/code/area/","text":"Compute area // ---------------------------------------------------------------------------- // To compute area of a feature. // ---------------------------------------------------------------------------- var area_buffer = buffer . area (); print ( 'area of buffer' , area_buffer ); var buffer_with_area = buffer . set ({ area : area_buffer }); print ( 'buffer with area' , buffer_with_area );","title":"Compute area"},{"location":"02/code/buffer/","text":"Buffer a feature // ---------------------------------------------------------------------------- // To buffer a feature. // ---------------------------------------------------------------------------- var buffer = point01 . buffer ( 1000 ); print ( 'buffer a feature' , buffer ); Map . addLayer ( buffer , { color : 'blue' }, 'Buffer a feature' , 0 );","title":"Buffer a feature"},{"location":"02/code/centerObject/","text":"Center map on object // ---------------------------------------------------------------------------- // Center map on object. // ---------------------------------------------------------------------------- Map . centerObject ( point_collection , 14 ); // Add point_collection object to map as a layer. Map . addLayer ( XXXX , // data object XXXX , // display with black color XXXX , // label 'Point collection' X // shown by default should be true ) ;","title":"Center map on object"},{"location":"02/code/filterBounds/","text":"Filter for features that intersect feature collection // ---------------------------------------------------------------------------- // Filter for features that intersect another feature collection. // ---------------------------------------------------------------------------- var points_in_buffers = point_collection . filterBounds ( buffers ) ; Map . addLayer ( points_in_buffers , { color : 'magenta' }, 'Points in buffers from name filter' , 0 );","title":"Filter for features that interset feature collection"},{"location":"02/code/filterBounds_geometry/","text":"Filter for features that intersect geometry // ---------------------------------------------------------------------------- // Filter for features that intersect another feature's geometry. // ---------------------------------------------------------------------------- var points_in_buffer = point_collection . filterBounds ( buffer . geometry ()) ; Map . addLayer ( points_in_buffer , { color : 'red' }, 'Points in buffer' , 0 );","title":"Filter for features that intersect geometry"},{"location":"02/code/filter_eq/","text":"Filter by a nominal attribute // ---------------------------------------------------------------------------- // Filter collection by a nominal attribute. // ---------------------------------------------------------------------------- var points_filtered_by_name = point_collection . filter ( ee . Filter . eq ( 'name' , 'S' )) ; print ( 'selected by nominal attribute' , points_filtered_by_name ); Map . addLayer ( points_filtered_by_name , { color : 'yellow' }, 'Selected by name' , 0 );","title":"Filter by nominal attribute"},{"location":"02/code/filter_gt/","text":"Filter by a numeric attribute // ---------------------------------------------------------------------------- // Filter collection by a numeric attribute. // ---------------------------------------------------------------------------- var points_filtered_by_number = point_collection . filter ( ee . Filter . gt ( 'number' , 1 )) ; print ( 'selected by numeric attribute' , points_filtered_by_number ); Map . addLayer ( points_filtered_by_number , { color : 'cyan' }, 'Selected by number' , 0 );","title":"Filter by numeric attribute"},{"location":"02/code/intersection/","text":"Intersection of two features // ---------------------------------------------------------------------------- // Intersection two features. // ---------------------------------------------------------------------------- var intersection_features = buffer . intersection ( buffers . first ()); print ( 'Intersection of two features' , intersection_features ); Map . addLayer ( intersection_features , { color : 'gray' }, 'Intersection of two features' , 0 );","title":"Intersection of two features"},{"location":"02/code/map_area/","text":"Compute area of every feature in collection // ---------------------------------------------------------------------------- // To compute area of every feature in a collection: // ---------------------------------------------------------------------------- // 1. Define a function. var compute_area = function ( feature ) { var area_feature = feature . area (); var features_with_area = feature . set ({ area : area_feature }); return features_with_area ; }; // 2. Map function over collection. var buffers_with_area = buffers . map ( compute_area ); print ( 'buffers with area' , buffers_with_area );","title":"Compute area of every feature in collection"},{"location":"02/code/map_buffer/","text":"Buffer every feature in a collection // ---------------------------------------------------------------------------- // To buffer every feature in a collection: // ---------------------------------------------------------------------------- // 1. Define a function. var buffer_points = function ( point ){ var buffered_point = point . buffer ( 1000 ); return buffered_point ; } ; // 2. Map function over collection. var buffers = points_filtered_by_number . map ( buffer_points ); print ( 'buffer all featuers in collection filtered by number' , buffers ); Map . addLayer ( buffers , { color : 'green' }, 'Buffer all features in collection filtered by number' , 0 );","title":"Buffer every feature in collection"},{"location":"02/code/map_intersection/","text":"Intersection between a feature and collection // ---------------------------------------------------------------------------- // Intersection between a feature and collection. // ---------------------------------------------------------------------------- // 1. Define a function. var intersect_features = function ( feature ) { var intersection = feature . intersection ( buffer ); return intersection ; } ; // 2. Map function across collection. var intersection_feature_collection = buffers . map ( intersect_features ); print ( 'Intersection from feature collection' , intersection_feature_collection ); Map . addLayer ( intersection_feature_collection , { color : 'black' }, 'Intersection from feature collection' , 0 );","title":"Intersection between a feature and collection"},{"location":"02/code/print_first/","text":"Inspect first feature // ---------------------------------------------------------------------------- // Inspect the first feature in the collection. // ---------------------------------------------------------------------------- print ( 'First feature' , point_collection . first ());","title":"Inspect first feature"},{"location":"02/code/starter_coords/","text":"Vector objects // ---------------------------------------------------------------------------- // Vector objects. // ---------------------------------------------------------------------------- // Here are three starter coordinates stored as a dictionary. var coords = { pt1 : [ - 73.168687 , 44.013513 ], pt2 : [ - 73.156242 , 44.006167 ], pt3 : [ - 73.173494 , 44.008142 ] } ; // Here are three geometries constructed from these coordinates. var geometry = ee . Geometry . Point ( coords . pt1 ); var geometry2 = ee . Geometry . Point ( coords . pt2 ); var geometry3 = ee . Geometry . Point ( coords . pt3 ); // Here are three features. var point01 = ee . Feature ( geometry ,{ name : 'S' , number : 1 }); var point02 = ee . Feature ( geometry2 ,{ name : 'O' , number : 2 }); var point03 = ee . Feature ( geometry3 ,{ name : 'S' , number : 3 }); // Here is a feature collection that contains three features. var point_collection = ee . FeatureCollection ([ point01 , point02 , point03 ]); // Inspect the collection. print ( 'Point collection' , point_collection );","title":"Vector objects"},{"location":"02/code/table_widget/","text":"Display attributes of feature collection as a table So far, we have seen how to print attributes of features and feature collections to the Console. This is helpful when working through a solution and producing an answer to the problem, but less helpful when you want to share the results of your work with a general audience. In Earth Engine, you can show attributes of a feature collection as a table widget , also called a user-interface (ui) object. In the example below, we still just print the table to the Console, but eventually we will add the table to the map layout. The snippet below assumes that you have worked through the starter script so: You have a feature collection called large_owners (change this name to whatever you called your final result), Each feature in this collection has a property called \u2018OWNER1\u2019, Each feature also has a property called \u2018ACRES\u2019 that you want to sort the table by in descending order. // -------------------------------------------------------------------------------- // Display attributes of feature collection as a table. // -------------------------------------------------------------------------------- // In this example, large_owners contains the parts of parcels that overlap corridor with acres as an attribute. var results = ui . Chart . feature . byFeature ( large_owners , 'OWNER1' ); results . setChartType ( 'Table' ); results . setOptions ( { allowHtml : true , // Formatted values of cells with html tags will be rendered as HTML. pageSize : 50 , // The number of rows to show in each page. frozenColumns : 1 , // The number of columns from the left to 'freeze' when scrolling horizontally. Note that this works in the Console, but not when you open the table in a new browser panel. sort : 'enable' , // Users can click on a header to sort table by that column. sortAscending : false , // True = sort ascending; False = sort descending. sortColumn : 1 // Index of column to sort. 0 is first column, 1 is second. } ) ; results . style (). set ({ stretch : 'both' }); // Print table. print ( 'Land owners to contact' , results );","title":"Display attributes of feature collection as a table"},{"location":"02/code/union/","text":"Union features in a collection // ---------------------------------------------------------------------------- // Union features in a feature collection. // ---------------------------------------------------------------------------- var union_feature_collection = buffers . union (); print ( 'Union from feature collection' , union_feature_collection ); Map . addLayer ( union_feature_collection , { color : 'black' }, 'Union from feature collection' , 0 );","title":"Union features in collection"},{"location":"02/code/union_right/","text":"Union two features // ---------------------------------------------------------------------------- // Union two features. // ---------------------------------------------------------------------------- var union_features = buffer . union ( buffers . first ()); print ( 'Union of two features' , union_features ); Map . addLayer ( union_features , { color : 'gray' }, 'Union from two features' , 0 );","title":"Union two features"},{"location":"03/apply/protected_lands/","text":"Area-based conservation goals at the town scale In January 2022, Amy Sheldon of Middlebury introduced H.606 to the Committee on Natural Resources, Fish, and Wildlife in Montpelier, Vermont. \u201cAn act relating to community resilience and biodiversity protection\u201d would require the State of Vermont to protect 30 percent of lands and waters in the state by 2030 and 50 percent by 2050. The conserved land would permanently protect natural landcover with different degrees of human use and resource extraction and include a mixture of ecological reserve areas, biodiversity conservation areas, natural resource management areas, and sustainable forest management areas. For much of Vermont, natural land cover is forested land cover or early-successional forest cover, in contrast to open, bare, and impervious land cover maintained by agriculture and development. The bill passed the House in March and then passed the Senate two months later. On May 12, 2022, the bill was delivered to Governor Scott for his signature. On June 2, the Governor vetoed the bill and wrote: \u201cVermont has a long history of effective land conservation that has significantly contributed to the state\u2019s vibrant, resilient working landscape of farms and forests, vast natural areas, and world class opportunities for outdoor recreation. This is a result of flexible and innovative tools like our current use program and the payment-for-ecosystem-services model. These programs are critical to achieving our conservation priorities because they combine conservation planning with incentives \u2013 making it more attractive and affordable for Vermont families to keep and conserve their land, farms and forests. \u201cOver the course of the legislative session, the Agency of Natural Resources testified multiple times against this bill. Among the objections, the Agency pointed to the conservation goals established in H.606 are unnecessarily tied to \u2013 and unreasonably limited to \u2013 permanent protection. The Agency has repeatedly said that permanent preservation has not been, and cannot be, the state\u2019s exclusive conservation tool and this bill, intentional or not, would diminish the existing and successful conservation tools we have. Based on the objections outlined above, I am returning this legislation without my signature pursuant to Chapter II, Section 11 of the Vermont Constitution.\u201d Your goal for this week is to develop a tool to assess the landcover of lands with permanent protections and lands registered in the Current Use and Value Appraisal Program within any Vermont town and create a chart to evaluate 30 by \u201830 and 50 by \u201850 goals at the town scale. The app below illustrates the basic tool that you will make using the case of Middlebury, Vermont. Here is a link to the app that will open in a separate window.","title":"Area-based goals at the town scale"},{"location":"03/apply/starter_script/","text":"// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // TITLE: week_03_practice_problem.js // NAME: Your name here please // DATE: Today's date // PURPOSE: Town-scale analysis of protected and current use land cover. // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // Use the drawing tool to drop a point on Battell Bridge. // ---------------------------------------------------------------------------- // Data dictionary for problem. // ---------------------------------------------------------------------------- var data = { towns : 'projects/conservation-atlas/assets/cadastre/Boundary_TWNBNDS_poly' , lc : 'users/jhowarth/middCC/LandLandcov_BaseLC2016' , ag : 'projects/conservation-atlas/assets/landCover/lcAg_2016' , pro : 'projects/conservation-atlas/assets/protections/VT_Protected_Lands_Database' , uva : 'projects/conservation-atlas/assets/cadastre/Use_Value_Appraisal_Parcels' } ; // ---------------------------------------------------------------------------- // Create a map centered on a study region. // ---------------------------------------------------------------------------- // Load town feature collection from data.towns. // Filter study region by a poi. // Center on study region at zoom level 11. // Set base map to satellite with labels. // Add study region as a layer to map. // ---------------------------------------------------------------------------- // Display raster image as a map layer. // ---------------------------------------------------------------------------- // Construct a land cover image from data.land_cover. // Inspect image. // Define a palette to display land cover values. var lc_palette = [ '#A1E67E' , // 1. Tree Canopy '#F2F179' , // 2. Grass/Shrub '#f7f7f7' , // 3. Bare soil '#95C6E6' , // 4. Water '#525252' , // 5. Buildings 'white' , // 6. Roads '#cccccc' , // 7. 0ther pavement 'white' , // 8. Railroads ]; // Define visualization parameters. // Add layer to map. // ---------------------------------------------------------------------------- // Convert feature collection to a binary image. // ---------------------------------------------------------------------------- // Load a feature collection from data.ag. // Inspect first record of collection. // Add layer to map. // Create a function that gives each feature the property 'tag' with the value 1. // Apply function to all features in collection. // Inspect first record of collection. // Create a function to convert feature collection to image. // Apply function to feature collection. // Add binary image to map. // ---------------------------------------------------------------------------- // Map algebra: local operations between two raster layers. // ---------------------------------------------------------------------------- // Invert binary. // Erase inverted binary from landcover // Add a color for agriculture to palette list. // Inspect the palette. // Define vis parameters. // Add layer to map. // ---------------------------------------------------------------------------- // Generalize nominal attributes (aka reclassify). // ---------------------------------------------------------------------------- // Reclassify land cover // OLD VALUE OLD NAME NEW NAME NEW VALUE // 0 Ag Active Field 4 // 1 Tree canopy Forest 1 // 2 Grass/Shrub Old field 3 // 3 Bare soil Developed 5 // 4 Water Water 2 // 5 Buildings Developed 5 // 6 Roads Developed 5 // 7 Other pavement Developed 5 // 8 Railroads Developed 5 // Create list of old values. // Create list of new values. // Reclassify new values from old values. // Define palette for generalized layer. // Define vis parameters for generalized layer. // Add generalized layer to map. // ---------------------------------------------------------------------------- // Convert feature collection to binary image and apply as a mask layer. // ---------------------------------------------------------------------------- // Construct feature collection from data.pro. // Tag features. // Make image from tagged features. // Inspect result. // Add binary layer to map. // Add generalized layer to map with protected lands mask. // ---------------------------------------------------------------------------- // Convert feature collection to binary image and apply mask layers. // ---------------------------------------------------------------------------- // Construct feature collection from data.uva. // Tag features. // Make image from tagged features. // Inspect result. // Add binary layer to map. // Add generalized layer to map with protected lands mask. // Create a layer that represents UVA lands without permanent protections. // ---------------------------------------------------------------------------- // Compute area of a zone. // ---------------------------------------------------------------------------- // Create layer of pixel areas. // Inspect result. // Create parameters of zonal statistic. // Compute zonal statistic. // Inspect result. // ---------------------------------------------------------------------------- // Chart area of regions as a percent of zone. // ---------------------------------------------------------------------------- // Represent the percentage of the study region's area represented by the area of each pixel. // In other words, divide the area of each pixel by the area of the study region. // Rename this layer 'all of town'. // Inspect results. // Construct image with three dough bands and one cutter band. // Band 1 = pixel percentages // Band 2 = pixel percentages masked by protected lands // Band 3 = pixel percentages masked by uva lands without permanent protections // Band 4 = generalized land cover classes. // Inspect result. // ---------------------------------------------------------------------------- // Chart zonal statistic of each dough band with cutter zones. // ---------------------------------------------------------------------------- var lc_labels = [ '' , 'Tree canopy' , 'Water' , 'Old field' , 'Active field' , 'Developed' ] ; var chart_params = { image : simple_lc_area , classBand : 'land cover' , region : study_region , reducer : ee . Reducer . sum (), scale : 10 , classLabels : lc_labels , } ; var chart = ui . Chart . image . byClass ( chart_params ) . setChartType ( 'BarChart' ) . setOptions ({ title : 'Land cover in study region' , hAxis : { title : 'Percent of study region' , titleTextStyle : { italic : false , bold : true }, }, colors : simple_lc_palette , } ) ;","title":"Starter script"},{"location":"03/code/add_image_layer/","text":"Add image as a map layer Visualize data with color in three steps: define color palette, define range, data source, and palette, visualize as a map layer. // 1. Define color palette. // For nominal data, the number of color codes should equal the number of unique nominal values. var palette_name = [ 'color code' , // Describe label 'color code' , // Describe label '...' // # color codes should match # class codes ]; // 2. Define 'visualization parameters', or how values map to colors. var vis = { min : 0 , // Min class value for palette. max : 1 , // Max class value for palette. bands : [ 'name' ], // Source for class values. palette : palette_name , // Source for palette (range of colors) } ; // 3. Add as layer to map. map . addLayer ( data_object , // Band with values to visualize vis , // Range, source, and palette 'layer label' , // Layer label false , // Shown 1 // Opacity ) ;","title":"Add image as layer to map"},{"location":"03/code/apply_mask/","text":"Apply mask to an image // Apply binary raster as a mask on another raster. var image_with_mask = bottom_raster . updateMask ( binary_raster );","title":"Apply mask to image"},{"location":"03/code/chart_area_percent/","text":"Chart area of regions as a percent of a zone The snippets below creates the chart that is shown in the Land Cover app . Here are the main steps. (1) Convert pixel area into percentage decimal. The first step is to store the percent of the study region area represented by each pixel. To do this, we can divide the pixel area layer by a constant (the area of the study region). The snippet below gets this number from the output of a previous step (when we computed the area of the region). The snippet renames the band \u2018all of town\u2019. This will make the labels look cleaner in the chart at the end. // ---------------------------------------------------------------------------- // Chart areas of regions as a percent of a zone. // ---------------------------------------------------------------------------- // Convert pixel area into precentage decimal. var pixel_percentages = pixel_area_layer . divide ( area_study_region . getNumber ( 'area' )) . rename ( 'all of town' ) ; // Inspect the result. Notice the name of the band in this image. print ( 'pixel_percentage_layer' , pixel_percentages ); (2) Construct an image with dough and cutter bands. The next step is to set up the image that we will chart. The image needs to contain at least one band to use as the dough and one band to use as the cutter. The cutter must be the last band. The snippet below sets up three dough bands: Pixel percentages for an entire raster. Pixel percentages for just the protected lands. Pixel percentages for just the uva lands without any permanent protections. The last band in the image represents the cutters, or the zones that we want to compute the area for. The snippet also renames the bands again to make the labels on the chart at the end look cleaner. // Construct image with three dough bands and one cutter band. var simple_lc_area = pixel_percentages // Band with pixel percentages. . addBands ( pixel_percentages . updateMask ( protected_lands_image ) // Band with pixel percentages masked by protected lands binary. . addBands ( pixel_percentages . updateMask ( uva_not_protected )) // Band with pixel percentages masked by UVA binary without protections. . addBands ( simple_lc ) // Band with simple land cover classes. . rename ( 'protected in town' , 'uva without permanent protections in town' , 'land cover' ) // Labels for added bands. ) ; // Inspect the result. print ( 'simple_lc_area' , simple_lc_area ); (3) Chart zonal statistic for each dough band by cutter. // Chart zonal statistic for each dough band by cutter. // Create list of labels. The first item is a blank placeholder. The rest are labels for the cutters. var lc_labels = [ '' , 'Tree canopy' , 'Water' , 'Old field' , 'Active field' , 'Developed' ] ; // Create dictionary of chart arguments. var chart_params = { image : simple_lc_area , // Image with dough bands and cutter band. classBand : 'land cover' , // Name of the band to use as cutter. region : study_region , // Region to perform operation. reducer : ee . Reducer . sum (), // Type of zonal statistic to calculate. scale : 10 , // Scale to carry out operation. classLabels : lc_labels , // Labels of cutters to use in chart. } ; // Create the chart. var chart = ui . Chart . image . byClass ( chart_params ) // Dictionary of chart arguments. . setChartType ( 'BarChart' ) // Type of chart. . setOptions ({ title : 'Land cover in study region' , // Title for chart. hAxis : { title : 'Percent of study region' , // Title for horizontal axis. titleTextStyle : { italic : false , bold : true }, }, colors : simple_lc_palette , // Colors to use for chart. } ) ; // Inspect chart. print ( chart );","title":"Chart area of regions as percent of a zone"},{"location":"03/code/compute_area/","text":"Compute area of a zone This snippet shows how to compute the area of a region as a zonal statistic . A zonal statistic computes a statistic with the values of one layer in one or more zones defined by a second layer. I tend to think of the zones as cookie cutters and the image that provides the statistics as the cookie dough. We will draw this out in class. // Create a layer where each pixel value reports the pixel's area. var pixel_area_layer = ee . Image . pixelArea () ; // Inspect the result. This should be an image with one band named \"area\". print ( 'pixel area layer' , pixel_area_layer ); // Create a dictionary for reducer arguments. var reduce_params = { reducer : ee . Reducer . sum (), // Name of reducer geometry : cutter_features , // Cutter: Feature collection, feature, or geometry that defines the zone. scale : 10 , // Scale to perform operation. This usually needs to be coarser than dough image, otherwise Google complains about the work involved. maxPixels : 1e12 // How many pixels should Google work with before bailing on task? I usually set this at 1e12. } ; // Perform zonal statistic on dough by calling the dictionary defined above. var zonal_area_output = dough . reduceRegion ( reduce_params ); // Inspect results. print ( 'zonal area output' , zonal_area_output )","title":"Compute area of a zone"},{"location":"03/code/construct_image/","text":"Construct image from an address Use the ee.Image() method with a string argument (\u2018address\u2019). This will load an image referenced by the address into the variable that you name. // Construct image from address. var output_image = ee . Image ( 'address' );","title":"Construct image from address"},{"location":"03/code/convert_fc_to_binary/","text":"Convert feature collection to binary image This procedure begins with a feature collection and produces a binary raster, or a raster that shows the presence/absence of the features in the feature collection, where the cell contains the value 1 if it was covered by a feature\u2019s geometry and the value 0 if it was not covered. The procedure consists of two tasks and each task consists of three steps. Prep feature collection The first task prepares a feature collection for conversion. Write a function to give a feature a numeric property. Apply the function to every feature in a feature collection. Check to see if step 2 worked as you expected. You should see that each feature in the feature collection has a property and value that correspond with the .set() arguments in the function. // PREPARE FEATURE COLLECTION // Write a function to give a feature a property named 'tag' and a specified value. var tag_features = function ( feature ) { return feature . set ( { tag : 1 } // Property name and specified value ); } ; // Apply function to all features in a feature collection (fc). var tagged_fc = fc . map ( tag_features ); // Change fc to the name of feature collection. // Inspect first record of collection. print ( 'tagged fc' , tagged_fc . first ()); Convert feature collection The second task converts a feature collection into an image band. Write a function that creates a raster initialized with zeros, cast the raster as a \u2018byte\u2019 (which makes the raster \u2018smaller\u2019 with respect to storage), and then \u2018paint\u2019 the values from the specified feature property into the raster cells. Apply the function and specify the feature collection (to convert) and property (to paint). Inspect the result. This will print the result to the Console. Click on the carrot to see the list of bands. Because we made the raster with the .constant() method, the name of the band will be \u201cconstant\u201d. // CONVERT FEATURE COLLECTION TO IMAGE BAND // Create a function to convert feature collection to image. var makeImage = function ( fc , property ) { return ee . Image . constant ( 0 ) // Return a raster with zeros . byte () // Store as byte . paint ( fc , property ); // Paint values at locations from property of feature collection (fc). } ; // Call function with feature collection and property arguments. var image_output = makeImage ( tagged_fc , 'tag' ); // Inspect the result. print ( 'image from fc' , image_output );","title":"Convert feature collection to binary image"},{"location":"03/code/inspect_image/","text":"Inspect an image. You can print an image to the Console, though this won\u2019t visualize the image with color. It returns \u2018matadata\u2019 (data about data). Dry as this sounds you can learn some things from it. // Inspect an image. print ( 'label' , data_object ); // Where data_object is the name of the variable that holds the image. In the Console panel, expand the \u2018carrots\u2019 to explore the properties and bands of the image. Please note that an image will alway contain at least one band. The name of the band is in double quotes. The default name of the first band in an image is \u201cb1\u201d (short for band one). You can also inspect an image with the Inspector panel. With the crosshair, click on a location and the value of each band in each image at that location will print to the Inspector panel.","title":"Inspect image"},{"location":"03/code/map_algebra/","text":"Map algebra When two or more rasters have the same cell size, extent, orientation, and anchor (in other words, when the cells of two rasters align), you can perform algebra with the values in each cell. For example, a simple algebraic expression is: A * B = C. In map algebra , A and B are raster layers and the product C is also a raster layer. Again, the idea is that the computer calculates A * B = C for every location in the raster, always comparing the same cell location between the two input rasters and storing the product in the corresponding cell of the output raster. // Multiply value at each location for two images var raster_C = raster_A . multiply ( raster_B ); The table below lists some of the common algebraic operators. Math operator Method * .multiply() / .divide() + .add() - .subtract() Each of these operators can take either another raster or a constant as an argument. When the argument is another raster, the operator compares the values of each cell between two rasters. When the argument is a constant, the operator scales every value by the constant. This is common when converting between units of measurement. Map algebra can also be performed with logical operators. The two most common examples are intersection (and) and union (or). The table below shows the methods for each. Logical operator Method Intersection .and() Union .or() The output for logical comparisons is a binary raster, where the value 1 identifies where the expression is true and 0 where it is false.","title":"Map algebra"},{"location":"03/code/reclassify_image/","text":"Generalize (or reclassify) an image // Make list of old values. var old_values = [ 0 , 1 , 2 , 3 , 4 , 5 ]; // Make list of new values. The length of this list must be the same as list above. var new_values = [ 1 , 2 , 2 , 1 , 3 , 3 ]; // Replace old values with new values. var reclass_image = old_image . remap ( old_values , new_values );","title":"Generalize (reclassify) image"},{"location":"03/code/threshold_image/","text":"Threshold an image This happens when you apply a \u201ctrue or false\u201d criterion to a dataset. For example: true or false, x is equal to 0? The idea is that you ask this question for every cell in a raster and the computer answers the question by giving that cell either a 1 (if true) or 0 (if false). Often, threshold criteria are familiar math criteria. Math criterion Method equal to .eq() not equal to .neq() greater than .gt() greater than or equal to .gte() less than .lt() less than or equal to .lte() The example below shows the syntax for the \u2018equal to\u2019 criterion. If the input is a binary raster, the output will be the inverse. // Threshold image by equality criterion. var output_image = input_image . eq ( 0 );","title":"Threshold an image"},{"location":"03/concepts/review_questions/","text":"Review questions How does a raster store attributes of locations? What data objects does Earth Engine provide to work with geographic information in a raster framework? What are similarities and differences between raster and vector models? How does a raster model display data values with colors ? How does a raster represent points , lines , and zones ? What are similarities and differences between thresholding and generalizing ? What are similarities and differences between map algebra and masks ? What are similarities and differences between computation of area in vector versus raster models? What towns have most to lose if UVA lands are developed? Who wins, who loses when setting 30 x \u201830 goal at state versus town scale?","title":"Review questions"},{"location":"04/apply/global_oceans/","text":"Global oceans Questions How does the elevation of the ocean\u2019s floor relate to phytoplankton blooms? How does sea surface temperature relate to phytoplankton blooms? How do sea surface temperatures and phytoplankton blooms change over seasons? How does one season differ from a long term average? How do these anomalies in sea surface temperature relate to hurricanes? Goal This week, we will use Earth Engine to compile map layers that allow us to explore these kinds of questions about global ocean systems. Here is a link to the app that will open in a separate window. Resources Global Circulation Part one: differential heating Part two: the three cells Part three: the Coriolis effect and winds Ocean\u2019s Green Machines SST and Hurricanes Earth Engine datasets \u2018NOAA/NGDC/ETOPO1\u2019 \u2018NASA/OCEANDATA/MODIS-Terra/L3SMI\u2019 MODIS","title":"Bathymetry, sea surface temperature, and chlorophyll-a"}]}