{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction These materials aim to help undergraduate students explore and understand changes in the global environment using Google Earth Engine. They introduce core concepts of geographic information systems and remote sensing, methods for implementing these concepts with Earth Engine\u2019s javascript code editor, and a series of real-world problems and applications. This is a work in progress. I will be using it in Fall 2022 to teach a course in Environmental Studies and Geography at Middlebury College and it will be updated continuously. I\u2019ve organized the primer into chapters that each contain about a week\u2019s worth of content. Each chapter contains three sections: Introduces key words, concepts, and principles of spatial analysis, spatial problem-solving, geographic information systems, and remote sensing. Introduces code snippets to implement concepts with Google Earth Engine\u2019s code editor. Sketches geographic and environmental problems for students to solve by bringing together concepts and code. I am also developing problem sets to assess near and far transfer of understanding. In my course, these function as exams and for that reason I keep them in a private repository. If you are an instructor who would like access to these materials, please contact me. Jeff Howarth Associate Professor of Geography Middlebury College, Middlebury, Vermont, USA jhowarth@middlebury.edu","title":"Introduction"},{"location":"00/code/account/","text":"You will need to sign up for a Google Earth Engine account. This is free for students. We will walk through the sign-up process in our first meeting. You sign up through the Google Earth Engine web site .","title":"Account"},{"location":"00/code/code_editor/","text":"Earth Engine Code Editor We will use the web-based Code Editor for Earth Engine. You might as well bookmark this site in your browser. It provides an interface for writing and running code, while also providing tools for managing files and assets, composing and inspecting maps, finding documentation, and printing results and widgets. The diagram shown below is from Google\u2019s Earth Engine documentation . As you can see, the Code Editor consists of a lot of panels and buttons. As you use the code editor, you will quickly become familiar with navigating the interface. In our first lab meeting, we will go over the following common tasks. Common Task Panel or button Manage files Scripts Assets Find help for tools Docs Write and run code Text Editor Save Inspect results Console Inspect locations Inspector Inspect tasks Tasks Navigate map Pan Zoom Change basemap Map Satellite Draw geometry Point Line Shape Rectangle","title":"Code Editor"},{"location":"00/code/javaScript101/","text":"JavaScript 101 The Code Editor lets you work with Earth Engine by writing code in JavaScript. Like any language, JavaScript has a vocabulary and grammar that you will learn through practice. This page introduces some key terms, syntax, and contexts for writing code with JavaScript. Like most of the pages tagged with in this primer, this page contains code snippets that you can copy and paste into the code editor to see their effects. To do this, open the code editor , copy and past the code snippets into it, and click RUN to execute the snippet. You can also save you script as a file by clicking the SAVE button. The file name should not have spaces and should end with .js to mark that it is a JavaScript file (e.g. javascript101.js ). Scripts A script is a sequence of statements that can be executed (when you \u2018run\u2019 the script). Lines A line is the basic organizing unit of a script. Think of a line like a ruling on a sheet of paper, while a statement is like the sentence that you write on the ruling. Each line has a number, shown on the left side of the text editor panel. These line indexes are helpful for troubleshooting code because if you make an error the code editor will usually tell you the line number that tripped it up. Comments A comment tells the computer: please ignore this . You often use comments to document your code and write little notes to yourself and to people who may read and want to reuse your code. They are like putting notes in the margins of a book without affecting the content of the book or like the director\u2019s commentary of a movie that can be muted when you watch. A line comment tells the computer not to execute anything that follows two forward slashes on a line. A multi-line comment tells the computer not to execute anything from a defined beginning and ending which may span multiple lines. // LINE COMMENTS start with two forward slashes. Like this line. The computer won't execute anything on this line that follows the slashes. /* MULTI LINE COMMENTS start with a forward slash and a star and end with a star and a forward slash. The computer won't execute anything between the stars, even if your comment spans many many lines . */ Script header It is good practice to begin every script with a header that states a title, your name, the date, and a brief description of the script\u2019s purpose. To do this, you can use either a line comment or multi-line comment. Here is an example of a header with line comments. Note how each line begins with two forward slashes. // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // TITLE: Javascript 101 // NAME: Your name here please // DATE: Today's date // PURPOSE: Getting started with JavaScript // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Here is an example of a header with a multi-line comment. /* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ TITLE: Javascript 101 NAME: Your name here please DATE: Today's date PURPOSE: Getting started with JavaScript ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */ Either method is fine. The most important thing is to remember to start each script with a header. Statements, objects, and variables When you write a script, you write statements to create and manipulate different kinds of data objects . An object class is an abstract template, while an instance is a manifestation of it. For example, the concept of \u2018a book\u2019 is like an object class, while \u2018the book sitting next to your bed\u2019 is an instance of this class. Sometimes you hear the words \u201ctype\u201d and \u201ctoken\u201d to describe the same distinction. A common statement involves first creating a container to store something and then putting an instance of a class into the container. In JavaScript, the container is called a variable . A variable can store different kinds of objects and you can name the variable (almost) anything that you want. // This statement creates the variable age_daughter to store an instance of a NUMBER object. var age_daughter = 4 ; // This statement creates the variable age_son to store an instance of a STRING object. A string starts and ends with a single quote. var age_son = 'six years old' ; // A string object can also start and end with double quotes, // (but don't mix and match them). var name_daughter = \"isabel\" ; // This variable stores a set of strings as a LIST object that is defined by square brackets. var kid_names = [ 'Aldo' , 'Isabel' ]; // This list stores a set of numbers. var kid_ages = [ 6 , 4 ]; // Curly brackets (or braces) can be used to define DICTIONARIES, or a set of KEY:VALUE pairs. var kidStats = { 'name' : 'Aldo' , 'age' : 6 , 'birthplace' : 'Middlebury, VT' }; Statement syntax If you examine these simple statements, you might recognize some basic rules of syntax. 1. How do you define a variable? In JavaScript, the statement starts with the keyword var followed by the equal sign. That clause says \u2018create a variable named\u2026\u2019. 2. What do you notice about the variable names? They follow a simple rule: The name of a variable cannot contain spaces. To honor this rule, you can follow two naming conventions for variables. // An example of the snake_case. var this_will_work = 'snake_case' ; // An example of the camelCase. var thisWillAlsoWork = 'camelCase' ; 3. What defines the object class of the instance? This is subtle, but important. The object class is coded by the format of the text in the statement. OBJECT CLASS FORMAT EXAMPLE NUMBER plain old number 4 STRING \u2018 \u2018 \u201d \u201c \u2018isabel\u2019 \u201ckid\u2019s\u201c LIST [ ] [\u2018aldo\u2019, \u2018isabel\u2019] DICTIONARY {:} {\u2018name\u2019: \u2018aldo\u2019} 4. How does each statement end? Do you see that little thing at the end of each statement winking at you? This is a mark of good coding practice: Statements should end in a semi-colon . // Statements should end in a SEMI-COLON, or the editor complains. var dangling = 'I feel incomplete...' var complete = 'This feels better, thanks.' ; In the above example, the editor will flag the line with a little italic i when you forget the semi-colon, but you may not notice this because the code will often still run. As you learn to write more complicated statements, however, forgetting to include a semi-colon can torpedo your code from executing. So it is good practice to think of the semi-colon as the period of a sentence and always end with it. Code documentation It is good practice to write comments to document every statement in your code. This will help you read your code if you put a script down for a period of time and return to it later. It will also help other people read and borrow from your code or help you troubleshoot errors. In this course, I will ask you to follow three principles of good coding practice with respect to documenting your scripts. 1. Write a comment for each statement that briefly describes its purpose. 2. Always document code with complete sentences that end with periods. 3. Write concise 1-2 sentence statements, not long-winded paragraphs. Print to console panel As you write code, it is good practice to check your work as you go. A common way of doing this is to print variables and then look at the result in the Console panel of the Code Editor. // Use print function and pass a string to it by enclosing in parentheses. print ( 'This string will print in the Console panel.' ); // You can also pass a variable to the print function. print ( kid_names ); // Use commas to pass more than one item to the print function. print ( \"my kids\" , kid_names ); Functions The print command is an example of a function , or something more like a verb than a noun. A function can take arguments and deliver results. As illustrated by the print function, you pass arguments to a function by enclosing them in parentheses. Object methods Every object class will have a set of functions that you can call to manipulate instances of that object class. These are often called methods . Here is an example for a list object. // Use a period and parentheses to call a METHOD of an object (a function that works with an object). var kids_reversed = kid_names . reverse (); print ( 'Kids in reverse order' , kids_reversed ); Earth Engine objects All the examples above deal with native JavaScript objects and methods. Earth Engine provides a large set of additional objects and methods for working with geographic information. In the chapters that follow, you will learn how to use JavaScript to access these tools. The syntax and grammar for using these tools are largely the same as what we have discussed above. If this all feels new and slightly overwhelming, please do not stress out. It will become familiar through practice. Adapted from Earth Engine 101 by Dave Thau .","title":"Javascript 101"},{"location":"01/apply/discussion/","text":"Discussion Drawing lines on Mercator The True Size of SIN-EWR on sphere SIN-EWR last weekend Geographic friction EWR-SIN last weekend Geopolitical friction","title":"Discussion"},{"location":"01/apply/longest_haul/","text":"The Shortest Route for the Longest Haul Currently, the longest non-stop commercial flight connects Singapore (SIN) to Newark (EWR). Does the flight path follow the great circle route between the two airports? In theory, this route represents the shortest geographic distance between these two locations. To begin to answer this question, please create a map that shows the great circle route between the two airports. Please copy and paste the starter script (below) into the code editor and then save it to your repo. Please write one or more lines of code to \u2018answer\u2019 each prompt. We will discuss both your solution (script) and our original question (does the flight follow the great circle route?) in our next class meeting. At that time, I will also show you how to submit your scripts and document your coursework this semester. Starter script // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // Problem: The longest haul // Date: Today's date // Student: Your name here please // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // Construct point geometry objects for SIN and EWR. // Construct line geometry object between the two airports. // Calculate the length of the route. // Make a feature called 'longest_haul' with the line geometry and the distance of the flight as an attribute. // Inspect the result by printing to Console. // Center the map as follows: // latitude: -0.9678795804756186 // longitude: -82.83931467161779 // zoom level: 3 // Change the base map to hybrid. // Add the line feature to the map, display it with red, and label the layer 'Longest haul route'. Airport support To help you find the airports, here is a screen shot that shows the location of SIN: And here is another that shows the location of EWR.","title":"Shortest route for the longest haul"},{"location":"01/code/addLayer/","text":"Add layer to map If you have one or more point, line, or polygon objects stored as a variable, you can display the variable on the Map UI as a layer . The layer metaphor goes back to the days when people would place a mylar sheet on top of a reference map and then draw shapes on the mylar. Thus the reference map was the base layer and each mylar sheet put on top of it was a thematic layer . Even though we don\u2019t use mylar anymore, the map layer metaphor is helpful as a conceptual device. In the example below, I assume you have a point object named \u2018point\u2019. Map . addLayer ( point , // Geometry object to show on the map. { color : 'blue' }, // Color to display the objects. 'My first point' // A label for the layer that will appear in the label panel. ); Please note: If you don\u2019t seen the point on your map, it may be because it is not in your current map extent. So you will need to zoom out and pan around to find it. Check your understanding How would you change the display so that the point appears red?","title":"Add layer to map"},{"location":"01/code/calculateLength/","text":"Calculate length Geometry objects have implicit spatial properties, like length, area, center, etc. Earth Engine provides methods to calculate these for each geometry class. For example, the method .length() calculates the length of a line (or \u2018LineString\u2019) object. To call the method, you append .length() to the variable that stores the line object. The snippet below assumes that you have a line object named \u2018line\u2019. // Calculate the length of a line object. var line_length = line . length () ; // Inspect result. print ( 'route distance' , line_length ); Check your understanding What statement would you write to find the center of the line? Hint: use the Docs tab to look for a method associated with ee.Geometry.LineString that sounds like it would calculate the center of the line.","title":"Calculate line length"},{"location":"01/code/centerObject/","text":"Center map on an object You can also define your map extent so that the map centers on a geometry object, like a sample point or city center. In the example below, I assume you have a point object named \u2018point\u2019. // Center on a point. Map . centerObject ( point , 4 ); Check your understanding If you have the choice, should you center the map before you add a layer, or add a layer before you center the map, or do you think that the sequence really does not matter?","title":"Center map on object"},{"location":"01/code/constructFeature/","text":"Construct a feature A geometry object represents where , but not what is where. In other words, geometry objects represent geographic locations, but they do not describe conditions or properties of these locations. For example, you can store the location of a town with a geometry object, but not the town\u2019s name, population, area, etc. A feature object stores both the geometry and qualitative and/or quantitative properties of a location. Often, you will hear people who are accustomed to geographic information systems use the word attribute rather than property. For our purposes, they are synonymous. Usually, the attributes of features will be defined as part of a data product. But you can also define and alter attributes as necessary with code. Earth Engine provides a method to make features by calling ee.Feature(). As arguments (between the parentheses), it takes a geometry object and the attributes. The attributes must be defined as a dictionary with a key and a value. You might think of this like a data table: the key is the column title and the value is the row. The example below again assumes that you have a point object named \u2018point\u2019. // Set a property of point. var point_feature = ee . Feature ( point , { name : 'my first point' }); // Print the two different objects to compare. print ( 'Point as geometry' , point , 'Point as feature' , point_feature ); Check your understanding Try to change the name of the feature to 'Gulf of Guinea'. What does the statement now say?","title":"Construct a feature"},{"location":"01/code/constructLineGeometry/","text":"Construct line geometry A line consists of two or more points. When you stretch a string tightly between two points on a globe, you show the great circle route . This shows the shortest distance across the globe\u2019s surface between the two points. Google Earth Engine uses a spheroid model to represent line objects. The resulting lines represent great circle routes, just like if you were working with a string and a globe. Earth Engine provides a method to construct line objects from two or more points. You call the method with the phrase ee.Geometry.LineString(). It takes a list of points as an argument. // Construct two points. var point = ee . Geometry . Point ([ 0 , 0 ]); var point2 = ee . Geometry . Point ([ - 90 , 60 ]); // Construct line from two points. var line = ee . Geometry . LineString ([ point , point2 ]); // Inspect results. print ( 'Great circle arc' , line ); // Display result as a layer on the map. Map . addLayer ( line , { color : 'red' }, 'Great circle line' ); Check your understanding If this line represents the shortest distance between two points, why does the line bend rather than go straight?","title":"Construct line geometry"},{"location":"01/code/constructPointGeometry/","text":"Construct point geometry While you can create geometry objects with the drawing buttons in the upper-left of the Map user interface, you can also create them with code. Earth Engine provides a method to make a point from coordinates (x,y). You call the method with the phrase ee.Geometry.Point(). Then you tell it the coordinates in the parentheses. To work, the coordinates need to be in the form of a list. // Construct new point geometry object. var point = ee . Geometry . Point ([ 0 , 0 ]); // Inspect the result. print ( 'Point object' , point ); Check your understanding Which number represents the Prime Meridian Which number represents the Equator?","title":"Construct point geometry"},{"location":"01/code/convert_units/","text":"Convert units By default, Earth Engine often computes spatial measurements in meters. So length returns meters and area returns square meters. (It is good practice to use the docs tab in the code editor to double-check the units returned by your method.) You can convert these units into meters through simple math operations of number objects. The example below converts meters to kilometers. The snippet below assumes that you have a line object named \u2018line\u2019. // Calculate the length of a line object. var line_length_km = line . length () . divide ( 1000 ) ; // Inspect result. print ( 'route distance kilometers' , line_length_km ); Check your understanding How would you convert meters to miles?","title":"Convert units"},{"location":"01/code/getMapCenter/","text":"Get map center When you first open the Code Editor , the Map UI will be centered on a point in Buffalo Valley, OK. You can retrieve the coordinates of a map\u2019s center with this: // Get map center. var center = Map . getCenter (); print ( 'Center point' , center ); Please copy and paste the above code snippet into the Code Editor, then run it, and try to answer the questions below. Check your understanding: Please look at the Console Panel. Which number represents latitude and which represents longitude? What does it mean if a number is negative? Please write down the coordinates that you printed to the Console. Now click the pan button (the little glove in the upper left of the Map UI), then click the map and, while holding your click, drag towards your left. Now run the code again and try to answer the questions below. Check your understanding: Again, please look at the Console Panel. Which number changed the most when you panned? How did it change? Do you think you are moving the map when you pan, or are you moving the window through which you are looking at the map?","title":"Get map center"},{"location":"01/code/getZoom/","text":"Get zoom level By default, the map will always initialize so that you see all of the lower 48 states (plus Puerto Rico) in the map window. After panning the map in the last step, you have changed the region of the world displayed on the map. But you have not changed the amount of detail that the map displays. In the Map UI, zoom level defines the amount of detail displayed on the map. You can retrieve the zoom level used to display a map with this: // Get zoom level of map. var zoom = Map . getZoom (); print ( 'Zoom level' , zoom ); Check your understanding: Use the + and - buttons at the top left of the Map UI and re-run the code snippet to answer these two questions. What zoom level is the most 'zoomed out'? What zoom level is the most 'zoomed in'?","title":"Get zoom"},{"location":"01/code/setBasemap/","text":"Set base map By default, the Code Editor map will display with the Google road map. You can change the default basemap type like this: Map . setOptions ( 'HYBRID' ); You may choose from four base map types: \u2018ROADMAP\u2019 \u2018SATELLITE\u2019 \u2018HYBRID\u2019 \u2018TERRAIN\u2019 Check your understanding: What object type does this method take as a parameter?","title":"Set base map"},{"location":"01/code/setCenterZoom/","text":"Set map center and zoom level Together, map center and zoom level define a map\u2019s extent. You can customize the map extent by changing the map center and zoom level like this: // Set map center and zoom. Map . setCenter ( - 73.1812983597342 , 44.013157468373876 , 19 ); Check your understanding: At this zoom level, how many decimal places do you really need to center the map at this location? Hint: remove a decimal from the two coordinates and re-run the script. Repeat until you see first see BiHall move (just a tad).","title":"Set map center and zoom"},{"location":"01/concepts/geographic_framework/","text":"Geographic Framework Key terms equator prime meridian latitude longitude great circle zoom level representative fraction (RF) scale","title":"Geographic framework"},{"location":"01/concepts/modeling/","text":"Cartographic Modeling Key terms task ( goal ) task hierarchy workflow ( procedure , program )","title":"Cartographic modeling"},{"location":"01/concepts/transformations/","text":"Transformations Key terms Terms in italics are synonyms. input operation ( method ) output parameters ( arguments ) data types ( object classes )","title":"Transformations"},{"location":"01/concepts/vectorModel/","text":"Vector model Key terms Geometry (points, lines, polygons) Attributes (spatial, thematic) Singlepart versus multipart Properties","title":"Vector model"},{"location":"02/apply/corridor_easement_list/","text":"River corridor easement outreach The State of Vermont\u2019s Climate Action Plan anticipates that the next century will bring broad shifts in local patterns of precipitation and temperature. Annual temperatures are projected to increase over 2\u00b0F by 2050 and between 4 to 9\u00b0F by 2100. The number of days with extreme heat (defined by a high temperature of at least 90\u00b0F) are projected to double in frequency to nine days a year by 2050 and then increase to between 15 and 45 days a year by the century\u2019s end. Annual precipitation is projected to increase one to two inches by 2050 and between four and nine inches by 2100. Much of this increased precipitation will be delivered in higher intensity storms, as extreme precipitation events (those with more than two inches of rain in a 24-hour period) are expected to increase. These changes will directly impact the ecological function and habitat of lands for native plant and animal species. As a result, the goal of protecting 30 percent of terrestrial lands and waters by 2030 has been widely recognized as a pillar of climate change planning. The United Nations Convention on Biodiversity adopted 30 by \u201830 goal as one of ten \u2018milestones\u2019 in a global framework for managing nature through 2030. President Biden\u2019s 2021 \u201cExecutive Order on Tackling the Climate Crisis at Home and Abroad\u201d also adopted the 30 by \u201830 goal. In Vermont, the River Corridor Easement Program is one instrument available to compensate private land owners for extending protections on their lands. Your goal this week is to write a script in Earth Engine that identifies property owners with at least 50 acres of land within a designated river corridor for any watershed in Vermont. This tool could be used by municipal Conservation Commissions and private Land Trusts to contact land owners and initiate conversations that help us get closer to reaching 30 by \u201830 and subsequent 50 by \u201850 conservation goals. The app below illustrates that basic tool that you will make. Here is a link to the app that will open in a separate window. The CODE section below introduces the methods that you will use to make this app. Each snippet introduces a method with a toy case. Your task in our lab meeting will be to arrange these methods into a workflow that produces a map like the one shown above.","title":"River corridor easement outreach"},{"location":"02/apply/starter_script/","text":"// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // TITLE: week_02_practice_problem.js // NAME: Your name here please // DATE: Today's date // PURPOSE: Identify opportunities for river corridor easements. // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // Use the drawing tool to drop a point on the Battell Bridge. // -------------------------------------------------------------------------------- // 1. Load watersheds and filter for Vermont and study region. // -------------------------------------------------------------------------------- // Load watersheds from Earth Engine data catalog. Search for 'HUC12'. // Print first feature in collection in order to examine the table structure. // Filter the feature collection by attribute to keep only watersheds in the state of Vermont. // Create a study region by selecting the Vermont watershed that intersects the point of interest. // -------------------------------------------------------------------------------- // 2. Set up map and add watershed layers. // -------------------------------------------------------------------------------- // Center map study region and set zoom 11. // Set base map to satellite image with labels. // Add layer of Vermont watersheds to map. Use color 'LightCyan' and 0.5 opacity. // Add layer of study region to map. Use color 'PaleTurquoise' // ================================================================================ // Dataset addresses that are not in Earth Engine Data Catalog. // ================================================================================ var datasets = { parcels : 'projects/conservation-atlas/assets/cadastre/VTPARCELS_poly_standardized_parcels_SP_v1' , river_corridors : 'projects/conservation-atlas/assets/hydrology/WaterHydro_RiverCorridors_poly' , } ; // -------------------------------------------------------------------------------- // 3. Show river corridor that overlaps the study region. // -------------------------------------------------------------------------------- // Construct a feature collection from the river corridors address. // Filter the collection for features that intersect the study region. // Union the features within the collection. // Add the result from the last step to the map. Use color 'LightSkyBlue'. // -------------------------------------------------------------------------------- // 4. Show property parcels that overlap the river corridor in the study region. // -------------------------------------------------------------------------------- // Construct a feature collection from the parcels address. // Filter the feature collection for features that intersect the river corridors in the study region. // Filter the feature collection by attribute to keep features that are parcels (not roads, water, etc). /* Please note: to do the last step (filter by attribute), you will need to: 1. Find the property keys for the features and figure out which one describes the parcel property type. 2. Then you need to find the list of values for this key (so that you can see how the data distinguishes owned parcels from roads, water, etc). */ // Add result from last step as layer to map. Use color 'Gainsboro'. // -------------------------------------------------------------------------------- // 5. Show intersections of parcels and river corridors in the study region. // -------------------------------------------------------------------------------- // Create function to intersect each parcel (from step 3) by river corridor (from step 3). // Please ask for help if you get stuck here. // Apply the function to every parcel in the featue collection. // Add the result to the map. Use color 'LightSkyBlue'. // -------------------------------------------------------------------------------- // 6. Show features that meet an area criterion. // -------------------------------------------------------------------------------- // Write a function to compute area of each feature and append result to each feature as the property 'ACRES'. // Filter the result of above for all features that are greater than 50 acres. // Add the result as a layer to map. Use color 'Orchid'. // -------------------------------------------------------------------------------- // 7. Display results as a table. // -------------------------------------------------------------------------------- // We will discuss this last step in class tomorrow.","title":"Starter script"},{"location":"02/code/aggregate_array/","text":"Inspect unique values of one property // ---------------------------------------------------------------------------- // Inspect all the unique values for one property of features in the collection. // ---------------------------------------------------------------------------- // 1. Get list. var value_list = point_collection . aggregate_array ( 'name' ) . distinct () . sort () ; // 2. Print list. print ( 'list of values' , value_list );","title":"Inspect unique values of one property"},{"location":"02/code/area/","text":"Compute area // ---------------------------------------------------------------------------- // To compute area of a feature. // ---------------------------------------------------------------------------- var area_buffer = buffer . area (); print ( 'area of buffer' , area_buffer ); var buffer_with_area = buffer . set ({ area : area_buffer }); print ( 'buffer with area' , buffer_with_area );","title":"Compute area"},{"location":"02/code/buffer/","text":"Buffer a feature // ---------------------------------------------------------------------------- // To buffer a feature. // ---------------------------------------------------------------------------- var buffer = point01 . buffer ( 1000 ); print ( 'buffer a feature' , buffer ); Map . addLayer ( buffer , { color : 'blue' }, 'Buffer a feature' , 0 );","title":"Buffer a feature"},{"location":"02/code/centerObject/","text":"Center map on object // ---------------------------------------------------------------------------- // Center map on object. // ---------------------------------------------------------------------------- Map . centerObject ( point_collection , 14 ); // Add point_collection object to map as a layer. Map . addLayer ( XXXX , // data object XXXX , // display with black color XXXX , // label 'Point collection' X // shown by default should be true ) ;","title":"Center map on object"},{"location":"02/code/filterBounds/","text":"Filter for features that intersect feature collection // ---------------------------------------------------------------------------- // Filter for features that intersect another feature collection. // ---------------------------------------------------------------------------- var points_in_buffers = point_collection . filterBounds ( buffers ) ; Map . addLayer ( points_in_buffers , { color : 'magenta' }, 'Points in buffers from name filter' , 0 );","title":"Filter for features that interset feature collection"},{"location":"02/code/filterBounds_geometry/","text":"Filter for features that intersect geometry // ---------------------------------------------------------------------------- // Filter for features that intersect another feature's geometry. // ---------------------------------------------------------------------------- var points_in_buffer = point_collection . filterBounds ( buffer . geometry ()) ; Map . addLayer ( points_in_buffer , { color : 'red' }, 'Points in buffer' , 0 );","title":"Filter for features that intersect geometry"},{"location":"02/code/filter_eq/","text":"Filter by a nominal attribute // ---------------------------------------------------------------------------- // Filter collection by a nominal attribute. // ---------------------------------------------------------------------------- var points_filtered_by_name = point_collection . filter ( ee . Filter . eq ( 'name' , 'S' )) ; print ( 'selected by nominal attribute' , points_filtered_by_name ); Map . addLayer ( points_filtered_by_name , { color : 'yellow' }, 'Selected by name' , 0 );","title":"Filter by nominal attribute"},{"location":"02/code/filter_gt/","text":"Filter by a numeric attribute // ---------------------------------------------------------------------------- // Filter collection by a numeric attribute. // ---------------------------------------------------------------------------- var points_filtered_by_number = point_collection . filter ( ee . Filter . gt ( 'number' , 1 )) ; print ( 'selected by numeric attribute' , points_filtered_by_number ); Map . addLayer ( points_filtered_by_number , { color : 'cyan' }, 'Selected by number' , 0 );","title":"Filter by numeric attribute"},{"location":"02/code/intersection/","text":"Intersection of two features // ---------------------------------------------------------------------------- // Intersection two features. // ---------------------------------------------------------------------------- var intersection_features = buffer . intersection ( buffers . first ()); print ( 'Intersection of two features' , intersection_features ); Map . addLayer ( intersection_features , { color : 'gray' }, 'Intersection of two features' , 0 );","title":"Intersection of two features"},{"location":"02/code/map_area/","text":"Compute area of every feature in collection // ---------------------------------------------------------------------------- // To compute area of every feature in a collection: // ---------------------------------------------------------------------------- // 1. Define a function. var compute_area = function ( feature ) { var area_feature = feature . area (); var features_with_area = feature . set ({ area : area_feature }); return features_with_area ; }; // 2. Map function over collection. var buffers_with_area = buffers . map ( compute_area ); print ( 'buffers with area' , buffers_with_area );","title":"Compute area of every feature in collection"},{"location":"02/code/map_buffer/","text":"Buffer every feature in a collection // ---------------------------------------------------------------------------- // To buffer every feature in a collection: // ---------------------------------------------------------------------------- // 1. Define a function. var buffer_points = function ( point ){ var buffered_point = point . buffer ( 1000 ); return buffered_point ; } ; // 2. Map function over collection. var buffers = points_filtered_by_number . map ( buffer_points ); print ( 'buffer all featuers in collection filtered by number' , buffers ); Map . addLayer ( buffers , { color : 'green' }, 'Buffer all features in collection filtered by number' , 0 );","title":"Buffer every feature in collection"},{"location":"02/code/map_intersection/","text":"Intersection between a feature and collection // ---------------------------------------------------------------------------- // Intersection between a feature and collection. // ---------------------------------------------------------------------------- // 1. Define a function. var intersect_features = function ( feature ) { var intersection = feature . intersection ( buffer ); return intersection ; } ; // 2. Map function across collection. var intersection_feature_collection = buffers . map ( intersect_features ); print ( 'Intersection from feature collection' , intersection_feature_collection ); Map . addLayer ( intersection_feature_collection , { color : 'black' }, 'Intersection from feature collection' , 0 );","title":"Intersection between a feature and collection"},{"location":"02/code/print_first/","text":"Inspect first feature // ---------------------------------------------------------------------------- // Inspect the first feature in the collection. // ---------------------------------------------------------------------------- print ( 'First feature' , point_collection . first ());","title":"Inspect first feature"},{"location":"02/code/starter_coords/","text":"Vector objects // ---------------------------------------------------------------------------- // Vector objects. // ---------------------------------------------------------------------------- // Here are three starter coordinates stored as a dictionary. var coords = { pt1 : [ - 73.168687 , 44.013513 ], pt2 : [ - 73.156242 , 44.006167 ], pt3 : [ - 73.173494 , 44.008142 ] } ; // Here are three geometries constructed from these coordinates. var geometry = ee . Geometry . Point ( coords . pt1 ); var geometry2 = ee . Geometry . Point ( coords . pt2 ); var geometry3 = ee . Geometry . Point ( coords . pt3 ); // Here are three features. var point01 = ee . Feature ( geometry ,{ name : 'S' , number : 1 }); var point02 = ee . Feature ( geometry2 ,{ name : 'O' , number : 2 }); var point03 = ee . Feature ( geometry3 ,{ name : 'S' , number : 3 }); // Here is a feature collection that contains three features. var point_collection = ee . FeatureCollection ([ point01 , point02 , point03 ]); // Inspect the collection. print ( 'Point collection' , point_collection );","title":"Vector objects"},{"location":"02/code/table_widget/","text":"Display attributes of feature collection as a table So far, we have seen how to print attributes of features and feature collections to the Console. This is helpful when working through a solution and producing an answer to the problem, but less helpful when you want to share the results of your work with a general audience. In Earth Engine, you can show attributes of a feature collection as a table widget , also called a user-interface (ui) object. In the example below, we still just print the table to the Console, but eventually we will add the table to the map layout. The snippet below assumes that you have worked through the starter script so: You have a feature collection called large_owners (change this name to whatever you called your final result), Each feature in this collection has a property called \u2018OWNER1\u2019, Each feature also has a property called \u2018ACRES\u2019 that you want to sort the table by in descending order. // -------------------------------------------------------------------------------- // Display attributes of feature collection as a table. // -------------------------------------------------------------------------------- // In this example, large_owners contains the parts of parcels that overlap corridor with acres as an attribute. var results = ui . Chart . feature . byFeature ( large_owners , 'OWNER1' ); results . setChartType ( 'Table' ); results . setOptions ( { allowHtml : true , // Formatted values of cells with html tags will be rendered as HTML. pageSize : 50 , // The number of rows to show in each page. frozenColumns : 1 , // The number of columns from the left to 'freeze' when scrolling horizontally. Note that this works in the Console, but not when you open the table in a new browser panel. sort : 'enable' , // Users can click on a header to sort table by that column. sortAscending : false , // True = sort ascending; False = sort descending. sortColumn : 1 // Index of column to sort. 0 is first column, 1 is second. } ) ; results . style (). set ({ stretch : 'both' }); // Print table. print ( 'Land owners to contact' , results );","title":"Display attributes of feature collection as a table"},{"location":"02/code/union/","text":"Union features in a collection // ---------------------------------------------------------------------------- // Union features in a feature collection. // ---------------------------------------------------------------------------- var union_feature_collection = buffers . union (); print ( 'Union from feature collection' , union_feature_collection ); Map . addLayer ( union_feature_collection , { color : 'black' }, 'Union from feature collection' , 0 );","title":"Union features in collection"},{"location":"02/code/union_right/","text":"Union two features // ---------------------------------------------------------------------------- // Union two features. // ---------------------------------------------------------------------------- var union_features = buffer . union ( buffers . first ()); print ( 'Union of two features' , union_features ); Map . addLayer ( union_features , { color : 'gray' }, 'Union from two features' , 0 );","title":"Union two features"},{"location":"03/apply/protected_lands/","text":"Area-based conservation goals at the town scale In January 2022, Amy Sheldon of Middlebury introduced H.606 to the Committee on Natural Resources, Fish, and Wildlife in Montpelier, Vermont. \u201cAn act relating to community resilience and biodiversity protection\u201d would require the State of Vermont to protect 30 percent of lands and waters in the state by 2030 and 50 percent by 2050. The conserved land would permanently protect natural landcover with different degrees of human use and resource extraction and include a mixture of ecological reserve areas, biodiversity conservation areas, natural resource management areas, and sustainable forest management areas. For much of Vermont, natural land cover is forested land cover or early-successional forest cover, in contrast to open, bare, and impervious land cover maintained by agriculture and development. The bill passed the House in March and then passed the Senate two months later. On May 12, 2022, the bill was delivered to Governor Scott for his signature. On June 2, the Governor vetoed the bill and wrote: \u201cVermont has a long history of effective land conservation that has significantly contributed to the state\u2019s vibrant, resilient working landscape of farms and forests, vast natural areas, and world class opportunities for outdoor recreation. This is a result of flexible and innovative tools like our current use program and the payment-for-ecosystem-services model. These programs are critical to achieving our conservation priorities because they combine conservation planning with incentives \u2013 making it more attractive and affordable for Vermont families to keep and conserve their land, farms and forests. \u201cOver the course of the legislative session, the Agency of Natural Resources testified multiple times against this bill. Among the objections, the Agency pointed to the conservation goals established in H.606 are unnecessarily tied to \u2013 and unreasonably limited to \u2013 permanent protection. The Agency has repeatedly said that permanent preservation has not been, and cannot be, the state\u2019s exclusive conservation tool and this bill, intentional or not, would diminish the existing and successful conservation tools we have. Based on the objections outlined above, I am returning this legislation without my signature pursuant to Chapter II, Section 11 of the Vermont Constitution.\u201d Your goal for this week is to develop a tool to assess the landcover of lands with permanent protections and lands registered in the Current Use and Value Appraisal Program within any Vermont town and create a chart to evaluate 30 by \u201830 and 50 by \u201850 goals at the town scale. The app below illustrates the basic tool that you will make using the case of Middlebury, Vermont. Here is a link to the app that will open in a separate window.","title":"Area-based goals at the town scale"},{"location":"03/apply/starter_script/","text":"// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // TITLE: week_03_practice_problem.js // NAME: Your name here please // DATE: Today's date // PURPOSE: Town-scale analysis of protected and current use land cover. // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // Use the drawing tool to drop a point on Battell Bridge. // ---------------------------------------------------------------------------- // Data dictionary for problem. // ---------------------------------------------------------------------------- var data = { towns : 'projects/conservation-atlas/assets/cadastre/Boundary_TWNBNDS_poly' , lc : 'users/jhowarth/middCC/LandLandcov_BaseLC2016' , ag : 'projects/conservation-atlas/assets/landCover/lcAg_2016' , pro : 'projects/conservation-atlas/assets/protections/VT_Protected_Lands_Database' , uva : 'projects/conservation-atlas/assets/cadastre/Use_Value_Appraisal_Parcels' } ; // ---------------------------------------------------------------------------- // Create a map centered on a study region. // ---------------------------------------------------------------------------- // Load town feature collection from data.towns. // Filter study region by a poi. // Center on study region at zoom level 11. // Set base map to satellite with labels. // Add study region as a layer to map. // ---------------------------------------------------------------------------- // Display raster image as a map layer. // ---------------------------------------------------------------------------- // Construct a land cover image from data.land_cover. // Inspect image. // Define a palette to display land cover values. var lc_palette = [ '#A1E67E' , // 1. Tree Canopy '#F2F179' , // 2. Grass/Shrub '#f7f7f7' , // 3. Bare soil '#95C6E6' , // 4. Water '#525252' , // 5. Buildings 'white' , // 6. Roads '#cccccc' , // 7. 0ther pavement 'white' , // 8. Railroads ]; // Define visualization parameters. // Add layer to map. // ---------------------------------------------------------------------------- // Convert feature collection to a binary image. // ---------------------------------------------------------------------------- // Load a feature collection from data.ag. // Inspect first record of collection. // Add layer to map. // Create a function that gives each feature the property 'tag' with the value 1. // Apply function to all features in collection. // Inspect first record of collection. // Create a function to convert feature collection to image. // Apply function to feature collection. // Add binary image to map. // ---------------------------------------------------------------------------- // Map algebra: local operations between two raster layers. // ---------------------------------------------------------------------------- // Invert binary. // Erase inverted binary from landcover // Add a color for agriculture to palette list. // Inspect the palette. // Define vis parameters. // Add layer to map. // ---------------------------------------------------------------------------- // Generalize nominal attributes (aka reclassify). // ---------------------------------------------------------------------------- // Reclassify land cover // OLD VALUE OLD NAME NEW NAME NEW VALUE // 0 Ag Active Field 4 // 1 Tree canopy Forest 1 // 2 Grass/Shrub Old field 3 // 3 Bare soil Developed 5 // 4 Water Water 2 // 5 Buildings Developed 5 // 6 Roads Developed 5 // 7 Other pavement Developed 5 // 8 Railroads Developed 5 // Create list of old values. // Create list of new values. // Reclassify new values from old values. // Define palette for generalized layer. // Define vis parameters for generalized layer. // Add generalized layer to map. // ---------------------------------------------------------------------------- // Convert feature collection to binary image and apply as a mask layer. // ---------------------------------------------------------------------------- // Construct feature collection from data.pro. // Tag features. // Make image from tagged features. // Inspect result. // Add binary layer to map. // Add generalized layer to map with protected lands mask. // ---------------------------------------------------------------------------- // Convert feature collection to binary image and apply mask layers. // ---------------------------------------------------------------------------- // Construct feature collection from data.uva. // Tag features. // Make image from tagged features. // Inspect result. // Add binary layer to map. // Add generalized layer to map with protected lands mask. // Create a layer that represents UVA lands without permanent protections. // ---------------------------------------------------------------------------- // Compute area of a zone. // ---------------------------------------------------------------------------- // Create layer of pixel areas. // Inspect result. // Create parameters of zonal statistic. // Compute zonal statistic. // Inspect result. // ---------------------------------------------------------------------------- // Chart area of regions as a percent of zone. // ---------------------------------------------------------------------------- // Represent the percentage of the study region's area represented by the area of each pixel. // In other words, divide the area of each pixel by the area of the study region. // Rename this layer 'all of town'. // Inspect results. // Construct image with three dough bands and one cutter band. // Band 1 = pixel percentages // Band 2 = pixel percentages masked by protected lands // Band 3 = pixel percentages masked by uva lands without permanent protections // Band 4 = generalized land cover classes. // Inspect result. // ---------------------------------------------------------------------------- // Chart zonal statistic of each dough band with cutter zones. // ---------------------------------------------------------------------------- var lc_labels = [ '' , 'Tree canopy' , 'Water' , 'Old field' , 'Active field' , 'Developed' ] ; var chart_params = { image : simple_lc_area , classBand : 'land cover' , region : study_region , reducer : ee . Reducer . sum (), scale : 10 , classLabels : lc_labels , } ; var chart = ui . Chart . image . byClass ( chart_params ) . setChartType ( 'BarChart' ) . setOptions ({ title : 'Land cover in study region' , hAxis : { title : 'Percent of study region' , titleTextStyle : { italic : false , bold : true }, }, colors : simple_lc_palette , } ) ;","title":"Starter script"},{"location":"03/code/add_image_layer/","text":"Add image as a map layer Visualize data with color in three steps: define color palette, define range, data source, and palette, visualize as a map layer. // 1. Define color palette. // For nominal data, the number of color codes should equal the number of unique nominal values. var palette_name = [ 'color code' , // Describe label 'color code' , // Describe label '...' // # color codes should match # class codes ]; // 2. Define 'visualization parameters', or how values map to colors. var vis = { min : 0 , // Min class value for palette. max : 1 , // Max class value for palette. bands : [ 'name' ], // Source for class values. palette : palette_name , // Source for palette (range of colors) } ; // 3. Add as layer to map. map . addLayer ( data_object , // Band with values to visualize vis , // Range, source, and palette 'layer label' , // Layer label false , // Shown 1 // Opacity ) ;","title":"Add image as layer to map"},{"location":"03/code/apply_mask/","text":"Apply mask to an image // Apply binary raster as a mask on another raster. var image_with_mask = bottom_raster . updateMask ( binary_raster );","title":"Apply mask to image"},{"location":"03/code/chart_area_percent/","text":"Chart area of regions as a percent of a zone The snippets below creates the chart that is shown in the Land Cover app . Here are the main steps. (1) Convert pixel area into percentage decimal. The first step is to store the percent of the study region area represented by each pixel. To do this, we can divide the pixel area layer by a constant (the area of the study region). The snippet below gets this number from the output of a previous step (when we computed the area of the region). The snippet renames the band \u2018all of town\u2019. This will make the labels look cleaner in the chart at the end. // ---------------------------------------------------------------------------- // Chart areas of regions as a percent of a zone. // ---------------------------------------------------------------------------- // Convert pixel area into precentage decimal. var pixel_percentages = pixel_area_layer . divide ( area_study_region . getNumber ( 'area' )) . rename ( 'all of town' ) ; // Inspect the result. Notice the name of the band in this image. print ( 'pixel_percentage_layer' , pixel_percentages ); (2) Construct an image with dough and cutter bands. The next step is to set up the image that we will chart. The image needs to contain at least one band to use as the dough and one band to use as the cutter. The cutter must be the last band. The snippet below sets up three dough bands: Pixel percentages for an entire raster. Pixel percentages for just the protected lands. Pixel percentages for just the uva lands without any permanent protections. The last band in the image represents the cutters, or the zones that we want to compute the area for. The snippet also renames the bands again to make the labels on the chart at the end look cleaner. // Construct image with three dough bands and one cutter band. var simple_lc_area = pixel_percentages // Band with pixel percentages. . addBands ( pixel_percentages . updateMask ( protected_lands_image ) // Band with pixel percentages masked by protected lands binary. . addBands ( pixel_percentages . updateMask ( uva_not_protected )) // Band with pixel percentages masked by UVA binary without protections. . addBands ( simple_lc ) // Band with simple land cover classes. . rename ( 'protected in town' , 'uva without permanent protections in town' , 'land cover' ) // Labels for added bands. ) ; // Inspect the result. print ( 'simple_lc_area' , simple_lc_area ); (3) Chart zonal statistic for each dough band by cutter. // Chart zonal statistic for each dough band by cutter. // Create list of labels. The first item is a blank placeholder. The rest are labels for the cutters. var lc_labels = [ '' , 'Tree canopy' , 'Water' , 'Old field' , 'Active field' , 'Developed' ] ; // Create dictionary of chart arguments. var chart_params = { image : simple_lc_area , // Image with dough bands and cutter band. classBand : 'land cover' , // Name of the band to use as cutter. region : study_region , // Region to perform operation. reducer : ee . Reducer . sum (), // Type of zonal statistic to calculate. scale : 10 , // Scale to carry out operation. classLabels : lc_labels , // Labels of cutters to use in chart. } ; // Create the chart. var chart = ui . Chart . image . byClass ( chart_params ) // Dictionary of chart arguments. . setChartType ( 'BarChart' ) // Type of chart. . setOptions ({ title : 'Land cover in study region' , // Title for chart. hAxis : { title : 'Percent of study region' , // Title for horizontal axis. titleTextStyle : { italic : false , bold : true }, }, colors : simple_lc_palette , // Colors to use for chart. } ) ; // Inspect chart. print ( chart );","title":"Chart area of regions as percent of a zone"},{"location":"03/code/compute_area/","text":"Compute area of a zone This snippet shows how to compute the area of a region as a zonal statistic . A zonal statistic computes a statistic with the values of one layer in one or more zones defined by a second layer. I tend to think of the zones as cookie cutters and the image that provides the statistics as the cookie dough. We will draw this out in class. // Create a layer where each pixel value reports the pixel's area. var pixel_area_layer = ee . Image . pixelArea () ; // Inspect the result. This should be an image with one band named \"area\". print ( 'pixel area layer' , pixel_area_layer ); // Create a dictionary for reducer arguments. var reduce_params = { reducer : ee . Reducer . sum (), // Name of reducer geometry : cutter_features , // Cutter: Feature collection, feature, or geometry that defines the zone. scale : 10 , // Scale to perform operation. This usually needs to be coarser than dough image, otherwise Google complains about the work involved. maxPixels : 1e12 // How many pixels should Google work with before bailing on task? I usually set this at 1e12. } ; // Perform zonal statistic on dough by calling the dictionary defined above. var zonal_area_output = dough . reduceRegion ( reduce_params ); // Inspect results. print ( 'zonal area output' , zonal_area_output )","title":"Compute area of a zone"},{"location":"03/code/construct_image/","text":"Construct image from an address Use the ee.Image() method with a string argument (\u2018address\u2019). This will load an image referenced by the address into the variable that you name. // Construct image from address. var output_image = ee . Image ( 'address' );","title":"Construct image from address"},{"location":"03/code/convert_fc_to_binary/","text":"Convert feature collection to binary image This procedure begins with a feature collection and produces a binary raster, or a raster that shows the presence/absence of the features in the feature collection, where the cell contains the value 1 if it was covered by a feature\u2019s geometry and the value 0 if it was not covered. The procedure consists of two tasks and each task consists of three steps. Prep feature collection The first task prepares a feature collection for conversion. Write a function to give a feature a numeric property. Apply the function to every feature in a feature collection. Check to see if step 2 worked as you expected. You should see that each feature in the feature collection has a property and value that correspond with the .set() arguments in the function. // PREPARE FEATURE COLLECTION // Write a function to give a feature a property named 'tag' and a specified value. var tag_features = function ( feature ) { return feature . set ( { tag : 1 } // Property name and specified value ); } ; // Apply function to all features in a feature collection (fc). var tagged_fc = fc . map ( tag_features ); // Change fc to the name of feature collection. // Inspect first record of collection. print ( 'tagged fc' , tagged_fc . first ()); Convert feature collection The second task converts a feature collection into an image band. Write a function that creates a raster initialized with zeros, cast the raster as a \u2018byte\u2019 (which makes the raster \u2018smaller\u2019 with respect to storage), and then \u2018paint\u2019 the values from the specified feature property into the raster cells. Apply the function and specify the feature collection (to convert) and property (to paint). Inspect the result. This will print the result to the Console. Click on the carrot to see the list of bands. Because we made the raster with the .constant() method, the name of the band will be \u201cconstant\u201d. // CONVERT FEATURE COLLECTION TO IMAGE BAND // Create a function to convert feature collection to image. var makeImage = function ( fc , property ) { return ee . Image . constant ( 0 ) // Return a raster with zeros . byte () // Store as byte . paint ( fc , property ); // Paint values at locations from property of feature collection (fc). } ; // Call function with feature collection and property arguments. var image_output = makeImage ( tagged_fc , 'tag' ); // Inspect the result. print ( 'image from fc' , image_output );","title":"Convert feature collection to binary image"},{"location":"03/code/inspect_image/","text":"Inspect an image. You can print an image to the Console, though this won\u2019t visualize the image with color. It returns \u2018matadata\u2019 (data about data). Dry as this sounds you can learn some things from it. // Inspect an image. print ( 'label' , data_object ); // Where data_object is the name of the variable that holds the image. In the Console panel, expand the \u2018carrots\u2019 to explore the properties and bands of the image. Please note that an image will alway contain at least one band. The name of the band is in double quotes. The default name of the first band in an image is \u201cb1\u201d (short for band one). You can also inspect an image with the Inspector panel. With the crosshair, click on a location and the value of each band in each image at that location will print to the Inspector panel.","title":"Inspect image"},{"location":"03/code/map_algebra/","text":"Map algebra When two or more rasters have the same cell size, extent, orientation, and anchor (in other words, when the cells of two rasters align), you can perform algebra with the values in each cell. For example, a simple algebraic expression is: A * B = C. In map algebra , A and B are raster layers and the product C is also a raster layer. Again, the idea is that the computer calculates A * B = C for every location in the raster, always comparing the same cell location between the two input rasters and storing the product in the corresponding cell of the output raster. // Multiply value at each location for two images var raster_C = raster_A . multiply ( raster_B ); The table below lists some of the common algebraic operators. Math operator Method * .multiply() / .divide() + .add() - .subtract() Each of these operators can take either another raster or a constant as an argument. When the argument is another raster, the operator compares the values of each cell between two rasters. When the argument is a constant, the operator scales every value by the constant. This is common when converting between units of measurement. Map algebra can also be performed with logical operators. The two most common examples are intersection (and) and union (or). The table below shows the methods for each. Logical operator Method Intersection .and() Union .or() The output for logical comparisons is a binary raster, where the value 1 identifies where the expression is true and 0 where it is false.","title":"Map algebra"},{"location":"03/code/reclassify_image/","text":"Generalize (or reclassify) an image // Make list of old values. var old_values = [ 0 , 1 , 2 , 3 , 4 , 5 ]; // Make list of new values. The length of this list must be the same as list above. var new_values = [ 1 , 2 , 2 , 1 , 3 , 3 ]; // Replace old values with new values. var reclass_image = old_image . remap ( old_values , new_values );","title":"Generalize (reclassify) image"},{"location":"03/code/threshold_image/","text":"Threshold an image This happens when you apply a \u201ctrue or false\u201d criterion to a dataset. For example: true or false, x is equal to 0? The idea is that you ask this question for every cell in a raster and the computer answers the question by giving that cell either a 1 (if true) or 0 (if false). Often, threshold criteria are familiar math criteria. Math criterion Method equal to .eq() not equal to .neq() greater than .gt() greater than or equal to .gte() less than .lt() less than or equal to .lte() The example below shows the syntax for the \u2018equal to\u2019 criterion. If the input is a binary raster, the output will be the inverse. // Threshold image by equality criterion. var output_image = input_image . eq ( 0 );","title":"Threshold an image"},{"location":"03/concepts/review_questions/","text":"Review questions How does a raster store attributes of locations? What data objects does Earth Engine provide to work with geographic information in a raster framework? What are similarities and differences between raster and vector models? How does a raster model display data values with colors ? How does a raster represent points , lines , and zones ? What are similarities and differences between thresholding and generalizing ? What are similarities and differences between map algebra and masks ? What are similarities and differences between computation of area in vector versus raster models? What towns have most to lose if UVA lands are developed? Who wins, who loses when setting 30 x \u201830 goal at state versus town scale?","title":"Review questions"},{"location":"04/apply/global_oceans/","text":"Global oceans Questions How does the elevation of the ocean\u2019s floor relate to phytoplankton blooms? How does sea surface temperature relate to phytoplankton blooms? How do sea surface temperatures and phytoplankton blooms change over seasons? How does one season differ from a long term average? How do these anomalies in sea surface temperature relate to hurricanes? Goal This week, we will use Earth Engine to compile map layers that allow us to explore these kinds of questions about global ocean systems. Here is a link to the app that will open in a separate window. Resources Global Circulation Part one: differential heating Part two: the three cells Part three: the Coriolis effect and winds Ocean\u2019s Green Machines SST and Hurricanes Earth Engine datasets \u2018NOAA/NGDC/ETOPO1\u2019 \u2018NASA/OCEANDATA/MODIS-Terra/L3SMI\u2019 MODIS","title":"Global oceans"},{"location":"04/apply/starter_script/","text":"Starter script Please try to complete this script and submit a link to your code in this DROPBOX by the end of class. If you have worked until the end of lab and have not finished the script, please still submit a link to your script to the dropbox and try to complete the script before lecture tomorrow. // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // TITLE: week_05_practice_problem.js // NAME: Jeff Howarth // DATE: 10/12/22 // PURPOSE: Explore sst and chlorophyll-a of global oceans. // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // ------------------------------------------------------------------------ // 1. BATHYMETRY // ------------------------------------------------------------------------ // Load bathymetry dataset from 'NOAA/NGDC/ETOPO1' and select for 'bedrock' band. // Create a land mask. // Load the community palette module. // Select a community palette. // Please use cmocean.Deep[7]. // Please be sure deeper is darker colors and shallower elevations are lighter colors. // Config viz parameters. Stretch color palette over -5000 - 0 data values. // Add layer to map with land mask. // // ------------------------------------------------------------------------ // // 2. OCEAN WATER // // ------------------------------------------------------------------------ // Load 'NASA/OCEANDATA/MODIS-Terra/L3SMI'. Select 'sst' and 'chlor_a' bands. // Inspect first record and print size (number of images) of collection. // To filter image collection by calendarRange to make long term record. // 1. Define variables to make August and November the start and end months. // 2. Define 2000 and 2020 as start and end years for long term record. // 3. Filter by calendar range and call the startYear, endYear, startMonth, and endMonth variables defined above. // Reduce image collection into an image that represents the long term average (average value for each pixel). // Select community palette for sst. Please use colorbrewer.Spectral[11]. // Please make sure cool to warm colors map to cool to warm temperatures. // Define vis parameters for sst. Stretch palette from 10 to 30 data values. // Draw layer of sst long term average with land mask. // Select community palette for chorophyll-a. // Please use only the first six colors of niccoli.linearl[7]. // Define vis parameters for chlorophyl. Stretch values from 0 to 1 data values. // Draw chlorophyll-a layer with land mask. // ------------------------------------------------------------------------ // 3. ANOMALIES // ------------------------------------------------------------------------ // Define 2017 as the target year (or short term record). // Filter for the target year (defined above). // Inspect results. // Take the mean of the target and subtract the mean of the long term record. // Select community palette for sst anomaly. // Please use colorbrewer.RdBu[9]. // Please be sure cooler to warmer colors match cooler to warmer temperatures. // Define viz parameters. Stretch palette from -2 to 2 data values. // Select community palette for chlorophyll-a anomaly. // Define viz parameters. Stretch palette from -0.1 to 0.1. // Add anomaly layers to map.","title":"Starter script"},{"location":"04/apply/starter_script_02/","text":"Starter script (part 2) This script is already complete for you. You should be able to append it to the end of your part 1 script, update the name for the target year, and run. // ======================================================================== // 4. HURRICANES // ======================================================================== // Load and filter feature collection for target year (defined previously). // Also remove all features with 'max_wind_kts' equal to -99. var canes_fc = ee . FeatureCollection ( \"NOAA/NHC/HURDAT2/atlantic\" ) . filter ( ee . Filter . eq ( 'year' , targetYear )) // rename targetYear to match your script from part 1 . filter ( ee . Filter . neq ( 'max_wind_kts' , - 99 )) ; // Print the first feature in the collection. // Also print the 'min' and 'max' values of the 'max_wind_kts' property in the collection. print ( 'canes' , canes_fc . first (), 'min' , canes_fc . aggregate_min ( 'max_wind_kts' ), 'max' , canes_fc . aggregate_max ( 'max_wind_kts' ) ) ; // Center the map on the feature collection at zoom level 4. Map . centerObject ( canes_fc , 4 ); // Set base map to satellite with labels. Map . setOptions ( 'HYBRID' ); // Add feature collection to map as layer with color 'Ivory'. Map . addLayer ( canes_fc , { color : 'Ivory' }, 'Hurricane points' , 0 ); // ------------------------------------------------------------------------ // Prep and display canes as lines. // ------------------------------------------------------------------------ // Import a module for visualizing the hurricane data from 'users/jhowarth/eePrimer:modules/caneViz.js'. var caneViz = require ( 'users/jhowarth/eePrimer:modules/caneViz.js' ); // Call makeCaneLines() function from module to create hurricane track lines for each named storm. var caneLines = caneViz . makeCaneLines ( canes_fc ); // Print a list of the named storms for the target year. print ( 'cane lines' , caneLines . aggregate_array ( 'name' ) . distinct () . sort () ) ; // Add the track lines to the map as a layer. Display with 'DarkSlateGray' color. Map . addLayer ( caneLines , { color : 'DarkSlateGray' }, 'Cane lines' , 1 ); // ------------------------------------------------------------------------ // Set up map // ------------------------------------------------------------------------ // Display feature collection as graduated circles. // Step 1. Define viz paramters. // Call makeGraduatedCircles() function from module with four arguments. var caneGradSize = caneViz . makeGraduatedCircles ( targetYear , // Feature collection to symbolize. 6 , // Size of smallest point symbol. 'DarkRed' , // Color of point symbols. 0.5 // Opacity of point symbols. ); // Step 2. Create feature view layer. var gradCircles = caneViz . makeCaneLayer ( \"NOAA/NHC/HURDAT2/atlantic_FeatureView\" , // Address of featureView layer. caneGradSize , // Viz parameters for graduated cricles (you made this in the last step). 'Hurricane class' // Label for the layer. ) ; // Step 3. Add featureView layer to map. Map . add ( gradCircles ); // Note: use .add() with the object you made above as argument (rather than addLayer().","title":"Starter script (2)"},{"location":"04/code/community_palette/","text":"Community palette module ee-palettes is a resource created by Gennadii Donchyts, Fedor Baart & Justin Braaten. You can access this resource through the project\u2019s GitHub repository . The README file (the web page that is displayed when you click the GitHub link) thoroughly documents how to work with the resource. The snippets below aim to provide some additional support for EE newbies. 1. Load the module. In this community resource, palettes are contained in an Earth Engine module , or a collection of data objects that can be called from other scripts. This follows the modular programming paradigm that seeks to break complex tasks into simple, reusable sub-tasks. Many EE problems require the coder to create a palette to call as a visualization parameter. So rather than force all coders to do this from scratch each time, Gena, Fedor, and Justin wrote up a module that contains many different solutions to this task. Then they very kindly shared this module (for no cost) with the broader EE user community. The snippet below loads the ee-palettes module into a variable called palettes . // Load ee-palettes module. var palettes = require ( 'users/gena/packages:palettes' ); 2. Define a palette. The ee-palettes module contains a dictionary composed of sub-dictionaries, lists, and strings. To see this, run this snippet. // Inspect the module. print ( 'community palettes' , palettes ); In the Console, you should see a dictionary structured like this: Module dictionary Color schemes Palette groups Color lists To select a color list for your palette, use the following pattern: // Pattern for selecting palettes. var palette_name = // You can name this anything you want. module_dictionary . // Whatever you named the variable when you loaded the module. color_scheme . // Schemes organized by source (e.g. ColorBrewer) and sometimes data constraints (e.g. qualitative, sequential, diverging). palette_group // A general range of colors displayed by a palette. [ color_list_index ] // The list of colors used to display the palette (akin to the palette's 'resolution'). ; For example: // Define a palette. var palette = // Whatever you want to name the palette. palettes . // Whatever you named the variable when you loaded the module. cmocean . // Name of the color scheme. Deep // Name of the palette group. [ 7 ] // Index number of color list. ; print ( 'palette' , palette ); Typically, you call the palette in one line: // Define a palette. var palette = palettes . cmocean . Deep [ 7 ]; print ( 'palette' , palette ); 3. Invert the palette. Sometimes you will need to reverse the order of colors in a color list. For example, the Red-Blue diverging ColorBrewer scheme is inherently ordered from red to blue. But what if you want to use this palette to display temperature anomalies, where negative numbers represent cooler than normal temperatures and positive values represent warmer than normal temperatures? Good cartographic practice aims to make the visual display of data intuitive for the map reader. To use cool colors for cool temperatures and warm colors for warm temperatures, you can reverse the color list. // Define palette and reverse the color list. var palette_reversed = palettes . colorbrewer . RdBu [ 9 ]. reverse (); print ( 'palette reversed' , palette_reversed ); Go ahead and compared the result from above with the original palette to check your understanding. // Original palette. var palette_original = palettes . colorbrewer . RdBu [ 9 ]. reverse (); print ( 'palette original' , palette_original ); 3. Slice the palette. Sometimes you will want to use a portion of the palette, but not the entire palette. For example, imagine that you would like to map concentrations of chlorophyll-a. You find a palette from the niccoli color scheme that transitions from dark violet to green to white. For your map, you would like the palette to end at the green color and not extend into the yellow and white. To do this, you can slice the palette: // Slice the palette to use a portion of it. var palette_sliced = palettes . niccoli . linearl [ 7 ]. slice ( 0 , 5 ); print ( 'palette_sliced' , palette_sliced ); To understand how slice works, run this code to print the original palette. // Compare to original palette. var palette_full = palettes . niccoli . linearl [ 7 ]; print ( 'palette full' , palette_full ); Look at the Console panel and note that the original list contains seven (7) elements. Now expand the list (click on the carrot) so that you can see the color codes. Note that each color code in the list has an index number . The first color has the index 0 and the last color has the index 6. Now look at your sliced palette in the Console panel. It contains five (5) elements. The two arguments in the .slice() method defined the start and end of this subset. Note that the first number is inclusive and the second one is exclusive . That means when you say .slice(0,5) the result will include the index 0 but exclude the index 5 or greater. Resources for good cartographic practice Here are more resources for choosing color palettes for data visualization: ColorBrewer Scientific color maps Why we use bad color maps and what you can do about it Color in a perceptually uniform way","title":"Community palette module"},{"location":"04/code/filter_by_dates/","text":"Filter by dates An image collection often contains a time series , or a number of observations that are collected at some time interval over a duration of time. The interval between observations represents the temporal resolution of the collection and the duration of time represents the temporal extent . In most cases, you will want to work with a subset of images in an image collection based on a time window defined by your research question. You can filter the collection based on time constraints in a number of ways. Filter by date range The ee.Filter.date() method will filter an image collection by a start and end date. The start date is inclusive and the end date is exclusive . This means that a record with the start date will be included in the output, but a record that matches the end date will not. Both dates are strings in the format \u2018YYYY-MM-DD\u2019. For example, this snippet will filter an image collection for all records in January 2000. // Filter image collection with start and end dates. var output = input // Name of output and input . filter ( // Call the filter method. ee . Filter . date ( '2000-01-01' , '2000-02-01' ) // Call this particular filter with start and end dates. ) ; This method is used so frequently that EE provides a shorthand. // Shorthand for filtering image collection with start and end dates. var output = input . filterDate ( '2000-01-01' , '2000-02-01' ); Filter by calendar range Often your research question will concern a season or portion of time that recurs every year. For example, to study sea conditions during a hurricane season in the Atlantic, you would could filter for records between August and October. If you are studying one hurricane season, you could use the date range method. But if you wanted to make comparisons between hurricane seasons, then the date range method becomes laborious. For seasonal windows, it is often helpful to use the ee.Filter.calendarRange() method. This takes three arguments: start, end, and calendar unit. The first two are integers. The last is a string. And to make things fun, the start and end arguments are now both inclusive . For example, this snippet filters an image collection for all records between the years 2000 and 2010. Because the end number is inclusive, 2010 records will be returned in the output. // Filter image collection by year calendar range. var output = input . filter ( ee . Filter . calendarRange ( 2000 , 2010 , 'year' )) This snippet filters an image collection for all records between August and October of any year. Because the end number is inclusive, October records will be returned in the output. // Filter image collection by month calendar range. var output = input . filter ( ee . Filter . calendarRange ( 8 , 10 , 'month' )) You can also chain these filters together. This snippet filters an image collection for all records between August and October for the years between 2000 and 2010. // Filter image collection by year and month calendar ranges. var output = input . filter ( ee . Filter . calendarRange ( 2000 , 2010 , 'year' )) . filter ( ee . Filter . calendarRange ( 8 , 10 , 'month' ))","title":"Filter by dates"},{"location":"04/code/inspect_ic/","text":"Inspect image collection This pattern is similar to that for working with feature collections. An image collection usually contains a lot of images, so if you try to inspect the collection with the print() method, EE will often throw you an error because you are asking it to do too much work. Imagine if you asked a librarian to go into the stacks and bring you every issue that has ever been published by a journal or magazine. They too would likely turn red and balk at the request. So to politely get a sense of an image collection\u2019s contents, a good strategy is to print the first record and the number of records in the collection. // Inspect first record and print size (number of images) of collection. print ( 'label' , // Label for this request that is printed to Console. input . first (), // The first record in the image collection. input . size () // The number of records in the image collection. );","title":"Inspect image collection"},{"location":"04/code/load_ic/","text":"Load image collection This pattern resembles that for loading feature collections and images. You name a variable for the output and use the ee.ImageCollection() method. This takes the asset id as an argument and the asset id must be a string. // Load image collection. var ic_name = ee . ImageCollection ( 'address' );","title":"Load image collection"},{"location":"04/code/palettes_mb/","text":"Palette for multiband images One palette, one band. That is the simple mantra. If your image only contains one band, then there\u2019s no problem. EE will assume you want to display that one. If your image contains more than one band and your viz parameters includes a palette, then EE will throw you an error because it wants to know which band to display with that palette. One way to solve this problem is to specify the band in the viz parameters. // Viz parameter pattern for multiband images and one palette. var viz = { min : number , // The min data value to display. max : number , // The max data value to display. bands : 'band name' , // The band name as a string. palette : palette_name // The palette name (called by variable's name) }; Heads-up : the bands key in the viz dictionary is plural ( bands ) even though you only specify a single band.","title":"Palettes for multiband images"},{"location":"04/code/reduce_local_operation/","text":"Reduce with local operations An image collection often contains stacks of images where the images in the collection overlap each other. You can reduce the stack of images to a single image with a statistical operator. For example, if you have a stack of images in a collection where each image has bands that record the sea surface temperature and chlorophyll-a concentrations of a region over time, you can compute the mean value of each pixel in each band with the .mean() method. // Reduce image collection into an image that represents the mean value for each pixel in the collection. var output = input . mean (); If you explore the EE docs for image collections, you should be able to spot a number of these statistical and math reducers, including: .mean() .median() .max() .min() .product() .sum() All of these take an image collection as an input and reduce it to a single image. They also all do this operation for each band of every image.","title":"Reduce with local operations"},{"location":"04/code/select_bands/","text":"Select bands If you only need to work with a subset of bands from an image (or from every image in an image collection), it is good practice to select the bands early in your workflow. This lightens the load of your computation, which can help reduce your carbon footprint and save you time. Use the .select() method with the band name as an argument. // Select band from an image (or image collection) var output = input . select ( 'band_name' ); To select more than one band from the image, use a list of strings as the argument. // Select multiple bands from an image (or image collection) var output = input . select ([ 'first_band_name' , 'second_band_name' ]); It is often helpful to rename a band after you have selected it. This is not required. It can just be helpful, because the default names for bands are sometimes a bit weird and it can be nice to give them names that are more friendly and intuitive. To give your selected bands new names, add a second argument to the .select() method that defines the new names of the bands. The length of this second argument must match the length of the first. In other words, you need to provide one new name for each band. // Select multiple bands from an image (or image collection) var output = input . select ([ 'first_band_name' , 'second_band_name' ], [ 'first_band_new_name' , 'second_band_new_name' ]);","title":"Select bands"}]}